window.Aiken.initSearch([{"doc":"acca/address","title":"find_input_address","content":"find_input_address(maybe_input: Option&lt;Input&gt;) -&gt; Address\n Function that returns address for a given input","url":"acca/address.html#find_input_address"},{"doc":"acca/address","title":"acca/address","content":"","url":"acca/address.html"},{"doc":"acca/bytearray","title":"to_int","content":"to_int(self: ByteArray) -&gt; Int\n Convert a `ByteArray` from hexadecimal into the integer representation.\n This implementation uses BigEndian notation (also called network order),\n where data is represented sequentially starting from the most significant\n bit to the least significant.\n\n ```aiken\n bytearray.to_int(#&quot;&quot;) == 0\n bytearray.to_int(#&quot;414243&quot;) == 4276803\n ```","url":"acca/bytearray.html#to_int"},{"doc":"acca/bytearray","title":"acca/bytearray","content":"","url":"acca/bytearray.html"},{"doc":"acca/time","title":"must_start_after","content":"must_start_after(range: ValidityRange, lower_bound: PosixTime) -&gt; Bool\n","url":"acca/time.html#must_start_after"},{"doc":"acca/time","title":"must_start_before","content":"must_start_before(range: ValidityRange, lower_bound: PosixTime) -&gt; Bool\n","url":"acca/time.html#must_start_before"},{"doc":"acca/time","title":"acca/time","content":"","url":"acca/time.html"},{"doc":"aiken/dict","title":"delete","content":"delete(self: Dict&lt;key, value&gt;, key: key) -&gt; Dict&lt;key, value&gt;\n Remove a key-value pair from the dictionnary. If the key is not found, no changes are made.\n\n ```aiken\n dict.new()\n   |&gt; dict.insert(key: 14, value: 42, int.compare)\n   |&gt; dict.delete(key: 14)\n   |&gt; dict.get(14)\n // None\n ```","url":"aiken/dict.html#delete"},{"doc":"aiken/dict","title":"filter","content":"filter(self: Dict&lt;key, value&gt;, with: fn(key, value) -&gt; Bool) -&gt; Dict&lt;key, value&gt;\n Keep only the key-value pairs that pass the given predicate.","url":"aiken/dict.html#filter"},{"doc":"aiken/dict","title":"find","content":"find(self: Dict&lt;key, value&gt;, value: value) -&gt; Option&lt;key&gt;\n Finds a value in the dictionnary, and returns the first key found to have that value.\n\n ```aiken\n dict.new()\n   |&gt; dict.insert(key: foo, value: 42, bytearray.compare)\n   |&gt; dict.insert(key: bar, value: 14, bytearray.compare)\n   |&gt; dict.find(42)\n // Some(foo)\n ```","url":"aiken/dict.html#find"},{"doc":"aiken/dict","title":"fold","content":"fold(\n  self: Dict&lt;key, value&gt;,\n  with: fn(key, value, result) -&gt; result,\n  zero: result,\n) -&gt; result\n Fold over the key-value pairs in a dictionnary.","url":"aiken/dict.html#fold"},{"doc":"aiken/dict","title":"from_ascending_list","content":"from_ascending_list(\n  xs: List&lt;(key, value)&gt;,\n  compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Like [&#39;from_list&#39;](from_list), but from an already sorted list by ascending\n keys. This function fails (i.e. halt the program execution) if the list isn&#39;t\n sorted.\n\n This is meant to be used to turn a list constructed off-chain into a `Dict`\n which has taken care of maintaining interval invariants. This function still\n performs a sanity check on all keys to avoid silly mistakes. It is, however,\n considerably faster than","url":"aiken/dict.html#from_ascending_list"},{"doc":"aiken/dict","title":"from_list","content":"from_list(\n  self: List&lt;(key, value)&gt;,\n  compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Construct a dictionnary from a list of key-value pairs. Note that when a key is present\n multiple times, the first occurence prevails.","url":"aiken/dict.html#from_list"},{"doc":"aiken/dict","title":"get","content":"get(self: Dict&lt;key, value&gt;, key: key) -&gt; Option&lt;value&gt;\n Get a value in the dict by its key.\n\n ```aiken\n dict.new()\n   |&gt; dict.insert(key: foo, value: &quot;Aiken&quot;, bytearray.compare)\n   |&gt; dict.get(key: foo)\n // Some(&quot;Aiken&quot;)\n ```","url":"aiken/dict.html#get"},{"doc":"aiken/dict","title":"has_key","content":"has_key(self: Dict&lt;key, value&gt;, key: key) -&gt; Bool\n Check if a key exists in the dictionnary.\n\n ```aiken\n dict.new()\n   |&gt; dict.insert(key: foo, value: &quot;Aiken&quot;, bytearray.compare)\n   |&gt; dict.has_key(foo)\n // True\n ```","url":"aiken/dict.html#has_key"},{"doc":"aiken/dict","title":"insert","content":"insert(\n  self: Dict&lt;key, value&gt;,\n  key: key,\n  value: value,\n  compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Insert a value in the dictionnary at a given key key. If the key already exists, its value is **overridden**.\n\n ```aiken\n dict.new()\n   |&gt; dict.insert(key: foo, value: &quot;Foo&quot;, bytearray.compare)\n   |&gt; dict.insert(key: foo, value: &quot;Aiken&quot;, bytearray.compare)\n   |&gt; dict.to_list()\n // [(foo, &quot;Aiken&quot;)]\n ```","url":"aiken/dict.html#insert"},{"doc":"aiken/dict","title":"is_empty","content":"is_empty(self: Dict&lt;key, value&gt;) -&gt; Bool\n Efficiently checks whether a dictionnary is empty.","url":"aiken/dict.html#is_empty"},{"doc":"aiken/dict","title":"keys","content":"keys(self: Dict&lt;key, value&gt;) -&gt; List&lt;key&gt;\n Extract all the keys present in a given `Dict`.\n\n ```aiken\n dict.new()\n   |&gt; dict.insert(foo, 14, bytearray.compare)\n   |&gt; dict.insert(bar, 42, bytearray.compare)\n   |&gt; dict.insert(foo, 1337, bytearray.compare)\n   |&gt; dict.keys()\n // [foo, bar]\n ```","url":"aiken/dict.html#keys"},{"doc":"aiken/dict","title":"map","content":"map(self: Dict&lt;key, a&gt;, with: fn(key, a) -&gt; b) -&gt; Dict&lt;key, b&gt;\n Apply a function to all key-value pairs in a map.\n\n ```aiken\n pub fn celebrate_birthday(self: Dict&lt;ByteArray, Int&gt;, key: ByteArray) {\n   dict.map(self, with: fn(_key, value) { value + 1 })\n }\n ```","url":"aiken/dict.html#map"},{"doc":"aiken/dict","title":"new","content":"new() -&gt; Dict&lt;key, value&gt;\n Create a new map","url":"aiken/dict.html#new"},{"doc":"aiken/dict","title":"size","content":"size(self: Dict&lt;key, value&gt;) -&gt; Int\n Return the number of key-value pairs in the dictionnary.","url":"aiken/dict.html#size"},{"doc":"aiken/dict","title":"to_list","content":"to_list(self: Dict&lt;key, value&gt;) -&gt; List&lt;(key, value)&gt;\n Get the inner list holding the dictionnary data.","url":"aiken/dict.html#to_list"},{"doc":"aiken/dict","title":"union","content":"union(\n  left: Dict&lt;key, value&gt;,\n  right: Dict&lt;key, value&gt;,\n  compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Combine two dictionnaries. If the same key exist in both the left and\n right dictionnary, values from the left are preferred (i.e. left-biaised).","url":"aiken/dict.html#union"},{"doc":"aiken/dict","title":"union_with","content":"union_with(\n  left: Dict&lt;key, value&gt;,\n  right: Dict&lt;key, value&gt;,\n  with: fn(key, value, value) -&gt; Option&lt;value&gt;,\n  compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Like [`union`](#union) but allows specifying the behavior to adopt when a key is present\n in both dictionnaries.\n\n When passing `None`, the value is removed and not present in the union.","url":"aiken/dict.html#union_with"},{"doc":"aiken/dict","title":"values","content":"values(self: Dict&lt;key, value&gt;) -&gt; List&lt;value&gt;\n Combine two dictionnaries using the provided strategy for combining values when the same\n key is found in both dictionnaries.\n Extract all the values present in a given `Dict`.\n\n ```aiken\n dict.new()\n   |&gt; dict.insert(foo, 14, bytearray.compare)\n   |&gt; dict.insert(bar, 42, bytearray.compare)\n   |&gt; dict.insert(foo, 1337, bytearray.compare)\n   |&gt; dict.values()\n // [42, 1337]\n ```","url":"aiken/dict.html#values"},{"doc":"aiken/dict","title":"Dict","content":"Dict&lt;key, value&gt;\n An opaque `Dict`. The type is opaque because the module maintains some\n invariant, namely: there&#39;s only one occurence of a given key in the dictionnary.\n\n Note that the `key` parameter is a phantom-type, and only present as a\n means of documentation. Keys can be any type, yet will need to comparable\n to use functions like `insert`.\n\n See for example:\n\n ```aiken\n pub type Value =\n   Dict&lt;PolicyId, Dict&lt;AssetName, Int&gt;&gt;\n ```\n","url":"aiken/dict.html#Dict"},{"doc":"aiken/dict","title":"aiken/dict","content":" A module for working with bytearray dictionnaries.\n\n These dictionnaries are fundamentally ordered lists of key-value pairs,\n which preserve some invariants. In particular, each key is only present\n once in the dictionnary.","url":"aiken/dict.html"},{"doc":"aiken/string","title":"concat","content":"concat(left: String, right: String) -&gt; String\n Combine two `String` together.\n\n ```aiken\n string.concat(left: @&quot;Hello&quot;, right: @&quot;, World!&quot;) == @&quot;Hello, World!&quot;\n ```","url":"aiken/string.html#concat"},{"doc":"aiken/string","title":"from_bytearray","content":"from_bytearray(bytes: ByteArray) -&gt; String\n Convert a `ByteArray` into a `String`\n\n ```aiken\n string.from_bytearray(&quot;foo&quot;) == @&quot;foo&quot;\n string.from_bytearray(#&quot;666f6f&quot;) == @&quot;foo&quot;\n ```","url":"aiken/string.html#from_bytearray"},{"doc":"aiken/string","title":"from_int","content":"from_int(n: Int) -&gt; String\n Convert an `Int` to its `String` representation.\n\n ```aiken\n string.from_int(42) == @&quot;42&quot;\n ```","url":"aiken/string.html#from_int"},{"doc":"aiken/string","title":"join","content":"join(list: List&lt;String&gt;, delimiter: String) -&gt; String\n Join a list of strings, separated by a given _delimiter_.\n\n ```aiken\n string.join([], @&quot;+&quot;) == @&quot;&quot;\n string.join([@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;], @&quot;,&quot;) == @&quot;a,b,c&quot;\n ```","url":"aiken/string.html#join"},{"doc":"aiken/string","title":"to_bytearray","content":"to_bytearray(self: String) -&gt; ByteArray\n Convert a `String` into a `ByteArray`\n\n ```aiken\n string.to_bytearray(@&quot;foo&quot;) == &quot;foo&quot;\n ```","url":"aiken/string.html#to_bytearray"},{"doc":"aiken/string","title":"aiken/string","content":"","url":"aiken/string.html"},{"doc":"acca/ordering","title":"compare","content":"compare(left: Ordering, right: Ordering) -&gt; Ordering\n Left biased resolution of comparing two orderings.\n\n ```aiken\n aordering.compare(Less, Greater) == Less\n aordering.compare(Equal, Less) == Less\n aordering.compare(Equal, Equal) == Equal\n aordering.compare(Equal, Greather) == Greather\n aordering.compare(Greather, Less) == Greather\n ```","url":"acca/ordering.html#compare"},{"doc":"acca/ordering","title":"compare_option","content":"compare_option(\n  left: Option&lt;Ordering&gt;,\n  right: Option&lt;Ordering&gt;,\n) -&gt; Option&lt;Ordering&gt;\n Left biased resolution of comparing two orderings.\n\n ```aiken\n aordering.compare(Less, Greater) == Less\n aordering.compare(Equal, Less) == Less\n aordering.compare(Equal, Equal) == Equal\n aordering.compare(Equal, Greather) == Greather\n aordering.compare(Greather, Less) == Greather\n ```","url":"acca/ordering.html#compare_option"},{"doc":"acca/ordering","title":"compare_tuple","content":"compare_tuple(\n  left: (a, b),\n  right: (a, b),\n  first_compare: fn(a, a) -&gt; Ordering,\n  second_compare: fn(b, b) -&gt; Ordering,\n) -&gt; Ordering\n Compares two tuples with a given compare functions for both left and right side of the tuple.\n\n ```aiken\n aordering.compare_tuple((1, 2), (1, 2)) == Equal\n aordering.compare_tuple((0, 1), (1, 2)) == Less\n aordering.compare_tuple((2, 1), (1, 2)) == Greater\n aordering.compare_tuple((1, @&quot;a&quot;), (1, @&quot;a&quot;)) == Equal\n aordering.compare_tuple((1, @&quot;a&quot;), (1, @&quot;b&quot;)) == Less\n ```","url":"acca/ordering.html#compare_tuple"},{"doc":"acca/ordering","title":"compare_tuple_left","content":"compare_tuple_left(\n  left: (a, b),\n  right: (a, b),\n  first_compare: fn(a, a) -&gt; Ordering,\n) -&gt; Ordering\n Compares two tuples with a given compare functions for both left and right side of the tuple.\n This function will only look at left side of the tuple.\n\n ```aiken\n aordering.compare_tuple_left((1, 2), (1, 2)) == Equal\n aordering.compare_tuple_left((0, 1), (1, 2)) == Less\n aordering.compare_tuple_left((2, 1), (1, 2)) == Greater\n aordering.compare_tuple_left((1, @&quot;a&quot;), (1, @&quot;b&quot;)) == Equal\n ```","url":"acca/ordering.html#compare_tuple_left"},{"doc":"acca/ordering","title":"force_reduce","content":"force_reduce(self: List&lt;Ordering&gt;) -&gt; Ordering\n Reduces a List&lt;Ordering&gt; into one single Ordering.\n Note that reduction is left biased and function returns `Equal` for an empty list.\n\n ```aiken\n aordering.force_reduce([]) == Equal\n aordering.force_reduce([Less, Greater, Less]) == Less\n aordering.force_reduce([Equal, Less, Greater]) == Less\n aordering.force_reduce([Equal, Equal, Equal]) == Equal\n aordering.force_reduce([Equal, Equal, Equal, Greater]) == Greater\n ```","url":"acca/ordering.html#force_reduce"},{"doc":"acca/ordering","title":"reduce","content":"reduce(self: List&lt;Ordering&gt;) -&gt; Option&lt;Ordering&gt;\n Reduces a List&lt;Ordering&gt; into one single Ordering.\n Note that reduction is left biased.\n\n ```aiken\n aordering.reduce([]) == None\n aordering.reduce([Less, Greater, Less]) == Some(Less)\n aordering.reduce([Equal, Less, Greater]) == Some(Less)\n aordering.reduce([Equal, Equal, Equal]) == Some(Equal)\n aordering.reduce([Equal, Equal, Equal, Greater]) == Some(Greater)\n ```","url":"acca/ordering.html#reduce"},{"doc":"acca/ordering","title":"to_string","content":"to_string(ord: Ordering) -&gt; String\n Serialises ordering to string\n ```aiken\n aordering.to_string(Less) == @&quot;Less&quot;\n aordering.to_string(Equal) == @&quot;Equal&quot;\n aordering.to_string(Greater) == @&quot;Greater&quot;\n ```","url":"acca/ordering.html#to_string"},{"doc":"acca/ordering","title":"acca/ordering","content":"","url":"acca/ordering.html"},{"doc":"aiken/transaction/value","title":"add","content":"add(left: Value, right: Value) -&gt; Value\n Combine two `Value` together.","url":"aiken/transaction/value.html#add"},{"doc":"aiken/transaction/value","title":"flatten","content":"flatten(self: Value) -&gt; List&lt;(PolicyId, AssetName, Int)&gt;\n Flatten a value as list of 3-tuple (PolicyId, AssetName, Quantity).\n\n Handy to manipulate values as uniform lists.","url":"aiken/transaction/value.html#flatten"},{"doc":"aiken/transaction/value","title":"flatten_with","content":"flatten_with(\n  self: Value,\n  transform: fn(PolicyId, AssetName, Int) -&gt; Option&lt;result&gt;,\n) -&gt; List&lt;result&gt;\n Flatten a value as a list of results, possibly discarding some along the way.\n\n When the `transform` function returns `None`, the result is discarded altogether.","url":"aiken/transaction/value.html#flatten_with"},{"doc":"aiken/transaction/value","title":"from_asset","content":"from_asset(policy_id: PolicyId, asset_name: AssetName, quantity: Int) -&gt; Value\n Construct a `Value` from an asset identifier (i.e. `PolicyId` + `AssetName`)\n and a given quantity.","url":"aiken/transaction/value.html#from_asset"},{"doc":"aiken/transaction/value","title":"from_lovelace","content":"from_lovelace(quantity: Int) -&gt; Value\n Construct a `Value` from a lovelace quantity.\n\n Friendly reminder: 1 Ada = 1.000.000 Lovelace","url":"aiken/transaction/value.html#from_lovelace"},{"doc":"aiken/transaction/value","title":"lovelace_of","content":"lovelace_of(self: Value) -&gt; Int\n A specialized version of `quantity_of` for the Ada currency.","url":"aiken/transaction/value.html#lovelace_of"},{"doc":"aiken/transaction/value","title":"negate","content":"negate(self: Value) -&gt; Value\n Negates quantities of all tokens (including Ada) in that `Value`.\n\n ```\n v1\n   |&gt; value.negate\n   |&gt; value.add\n   |&gt; value.is_zero\n // True\n ```","url":"aiken/transaction/value.html#negate"},{"doc":"aiken/transaction/value","title":"policies","content":"policies(self: Value) -&gt; List&lt;PolicyId&gt;\n A list of all token policies in that Value with non-zero tokens.","url":"aiken/transaction/value.html#policies"},{"doc":"aiken/transaction/value","title":"quantity_of","content":"quantity_of(self: Value, policy_id: PolicyId, asset_name: AssetName) -&gt; Int\n Extract the quantity of a given asset.","url":"aiken/transaction/value.html#quantity_of"},{"doc":"aiken/transaction/value","title":"tokens","content":"tokens(self: Value, policy_id: PolicyId) -&gt; Dict&lt;AssetName, Int&gt;\n Get all tokens associated with a given policy.","url":"aiken/transaction/value.html#tokens"},{"doc":"aiken/transaction/value","title":"without_lovelace","content":"without_lovelace(self: Value) -&gt; Value\n Get a `Value` excluding Ada.","url":"aiken/transaction/value.html#without_lovelace"},{"doc":"aiken/transaction/value","title":"zero","content":"zero() -&gt; Value\n Construct an empty `Value` with nothing in it.","url":"aiken/transaction/value.html#zero"},{"doc":"aiken/transaction/value","title":"AssetName","content":"AssetName = ByteArray\n A type-alias for &#39;AssetName`, which are free-form byte-arrays between\n 0 and 32 bytes.\n","url":"aiken/transaction/value.html#AssetName"},{"doc":"aiken/transaction/value","title":"PolicyId","content":"PolicyId = Hash&lt;Blake2b_224, Script&gt;\n A type-alias for a `PolicyId`. A `PolicyId` is always 28-byte long\n","url":"aiken/transaction/value.html#PolicyId"},{"doc":"aiken/transaction/value","title":"Value","content":"Value\n A multi-asset output `Value`. Contains tokens indexed by [PolicyId](#PolicyId) and [AssetName](#AssetName).\n\n This type maintain some invariants by construction; in particular, a `Value` will never contain a\n zero quantity of a particular token.\n","url":"aiken/transaction/value.html#Value"},{"doc":"aiken/transaction/value","title":"ada_asset_name","content":"ada_asset_name: ByteArray = #&quot;&quot;\n Ada, the native currency, isn&#39;t associated with any `AssetName` (it&#39;s not\n possible to mint Ada!).\n\n By convention, it is an empty `ByteArray`.","url":"aiken/transaction/value.html#ada_asset_name"},{"doc":"aiken/transaction/value","title":"ada_policy_id","content":"ada_policy_id: ByteArray = #&quot;&quot;\n Ada, the native currency, isn&#39;t associated with any `PolicyId` (it&#39;s not\n possible to mint Ada!).\n\n By convention, it is an empty `ByteArray`.","url":"aiken/transaction/value.html#ada_policy_id"},{"doc":"aiken/transaction/value","title":"aiken/transaction/value","content":"","url":"aiken/transaction/value.html"},{"doc":"acca/predicate","title":"not","content":"not(predicate: fn(x) -&gt; Bool) -&gt; fn(x) -&gt; Bool\n","url":"acca/predicate.html#not"},{"doc":"acca/predicate","title":"acca/predicate","content":"","url":"acca/predicate.html"},{"doc":"acca/string","title":"compare","content":"compare(left: String, right: String) -&gt; Ordering\n","url":"acca/string.html#compare"},{"doc":"acca/string","title":"acca/string","content":"","url":"acca/string.html"},{"doc":"acca/collections/mt","title":"element_hash","content":"element_hash(self: MerkleElement&lt;a&gt;) -&gt; Hash&lt;Sha2_256, a&gt;\n","url":"acca/collections/mt.html#element_hash"},{"doc":"acca/collections/mt","title":"from_hashes_list","content":"from_hashes_list(items: List&lt;Hash&lt;Sha2_256, a&gt;&gt;) -&gt; MerkleElement&lt;a&gt;\n Construct a &#39;MerkleTree&#39; from a list of hashes.\n Note that, while this operation is doable on-chain, it is expensive and\n preferably done off-chain.","url":"acca/collections/mt.html#from_hashes_list"},{"doc":"acca/collections/mt","title":"from_list","content":"from_list(items: List&lt;a&gt;, serialise_fn: fn(a) -&gt; ByteArray) -&gt; MerkleElement&lt;a&gt;\n Construct a &#39;MerkleTree&#39; from a list of elements.\n Note that, while this operation is doable on-chain, it is expensive and\n preferably done off-chain.","url":"acca/collections/mt.html#from_list"},{"doc":"acca/collections/mt","title":"get_proof","content":"get_proof(\n  self: MerkleElement&lt;a&gt;,\n  item: a,\n  serialise_fn: fn(a) -&gt; ByteArray,\n) -&gt; Option&lt;Proof&lt;a&gt;&gt;\n Construct a membership &#39;Proof&#39; from an element and a &#39;MerkleTree&#39;. Returns\n &#39;None&#39; if the element isn&#39;t a member of the tree to begin with.\n Note function will return Some([]) in case root of the tree is also it&#39;s only one and only element","url":"acca/collections/mt.html#get_proof"},{"doc":"acca/collections/mt","title":"is_empty","content":"is_empty(self: MerkleElement&lt;a&gt;) -&gt; Bool\n Function that returns whether merkle tree has any elements","url":"acca/collections/mt.html#is_empty"},{"doc":"acca/collections/mt","title":"is_equal","content":"is_equal(left: MerkleElement&lt;a&gt;, right: MerkleElement&lt;a&gt;) -&gt; Bool\n Function atests whether two Merkle Tress are equal, this is the case when their root hashes match.","url":"acca/collections/mt.html#is_equal"},{"doc":"acca/collections/mt","title":"member","content":"member(\n  item: a,\n  element_hash: Hash&lt;Sha2_256, a&gt;,\n  proof: Proof&lt;a&gt;,\n  serialise_fn: fn(a) -&gt; ByteArray,\n) -&gt; Bool\n","url":"acca/collections/mt.html#member"},{"doc":"acca/collections/mt","title":"member_from_hash","content":"member_from_hash(\n  item_hash: Hash&lt;Sha2_256, a&gt;,\n  element_hash: Hash&lt;Sha2_256, a&gt;,\n  proof: Proof&lt;a&gt;,\n  serialise_fn: fn(a) -&gt; ByteArray,\n) -&gt; Bool\n","url":"acca/collections/mt.html#member_from_hash"},{"doc":"acca/collections/mt","title":"member_from_tree","content":"member_from_tree(\n  tree: MerkleElement&lt;a&gt;,\n  item: a,\n  serialise_fn: fn(a) -&gt; ByteArray,\n) -&gt; Bool\n","url":"acca/collections/mt.html#member_from_tree"},{"doc":"acca/collections/mt","title":"member_from_tree2","content":"member_from_tree2(\n  tree: MerkleElement&lt;a&gt;,\n  item: a,\n  serialise_fn: fn(a) -&gt; ByteArray,\n) -&gt; Bool\n","url":"acca/collections/mt.html#member_from_tree2"},{"doc":"acca/collections/mt","title":"size","content":"size(self: MerkleElement&lt;a&gt;) -&gt; Int\n Function returns a total numbers of leaves in the tree.","url":"acca/collections/mt.html#size"},{"doc":"acca/collections/mt","title":"MerkleElement","content":"MerkleElement&lt;a&gt;\n\n","url":"acca/collections/mt.html#MerkleElement"},{"doc":"acca/collections/mt","title":"Proof","content":"Proof&lt;a&gt; = List&lt;ProofItem&lt;a&gt;&gt;\n\n","url":"acca/collections/mt.html#Proof"},{"doc":"acca/collections/mt","title":"ProofItem","content":"ProofItem&lt;a&gt; {\n  Left { hash: Hash&lt;Sha2_256, a&gt; }\n  Right { hash: Hash&lt;Sha2_256, a&gt; }\n}\n\nLeft { hash: Hash&lt;Sha2_256, a&gt; }\n\nRight { hash: Hash&lt;Sha2_256, a&gt; }\n","url":"acca/collections/mt.html#ProofItem"},{"doc":"acca/collections/mt","title":"acca/collections/mt","content":"","url":"acca/collections/mt.html"},{"doc":"aiken/transaction/certificate","title":"Certificate","content":"Certificate {\n  CredentialRegistration { delegator: StakeCredential }\n  CredentialDeregistration { delegator: StakeCredential }\n  CredentialDelegation { delegator: StakeCredential, delegatee: PoolId }\n  PoolRegistration { pool_id: PoolId, vrf: Hash&lt;Blake2b_224, VerificationKey&gt; }\n  PoolDeregistration { pool_id: PoolId, epoch: Int }\n  Governance\n  TreasuryMovement\n}\n An on-chain certificate attesting of some operation. Publishing\n certificates / triggers different kind of rules; most of the time,\n they require signatures from / specific keys.\nCredentialRegistration { delegator: StakeCredential }\n\nCredentialDeregistration { delegator: StakeCredential }\n\nCredentialDelegation { delegator: StakeCredential, delegatee: PoolId }\n\nPoolRegistration { pool_id: PoolId, vrf: Hash&lt;Blake2b_224, VerificationKey&gt; }\n\nPoolDeregistration { pool_id: PoolId, epoch: Int }\n\nGovernance\n\nTreasuryMovement\n","url":"aiken/transaction/certificate.html#Certificate"},{"doc":"aiken/transaction/certificate","title":"aiken/transaction/certificate","content":"","url":"aiken/transaction/certificate.html"},{"doc":"aiken/bytearray","title":"compare","content":"compare(left: ByteArray, right: ByteArray) -&gt; Ordering\n Compare two bytearrays lexicographically.\n\n ```aiken\n bytearray.compare(#00, #FF) == Less\n bytearray.compare(#42, #42) == Equal\n bytearray.compare(#FF, #00) == Greater\n ```","url":"aiken/bytearray.html#compare"},{"doc":"aiken/bytearray","title":"concat","content":"concat(left: ByteArray, right: ByteArray) -&gt; ByteArray\n Combine two `ByteArray` together.\n\n ```aiken\n bytearray.concat(left: #[1, 2, 3], right: #[4, 5, 6]) == #[1, 2, 3, 4, 5, 6]\n ```","url":"aiken/bytearray.html#concat"},{"doc":"aiken/bytearray","title":"drop","content":"drop(self: ByteArray, n: Int) -&gt; ByteArray\n Returns the suffix of a `ByteArray` after `n` elements.\n\n ```aiken\n bytearray.drop(#[1, 2, 3], n: 2) == #[3]\n ```","url":"aiken/bytearray.html#drop"},{"doc":"aiken/bytearray","title":"foldl","content":"foldl(self: ByteArray, with: fn(Int, result) -&gt; result, zero: result) -&gt; result\n Left-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n\n ```aiken\n bytearray.foldl(#&quot;acab&quot;, fn(byte, acc) { acc * 256 + bytes }, 0) == 44203\n bytearray.foldl(#[1, 2, 3], flip(bytearray.push), #&quot;&quot;) == #[3, 2, 1]\n ```","url":"aiken/bytearray.html#foldl"},{"doc":"aiken/bytearray","title":"foldr","content":"foldr(self: ByteArray, with: fn(Int, result) -&gt; result, zero: result) -&gt; result\n Right-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n\n ```aiken\n bytearray.foldr(#&quot;acab&quot;, fn(byte, acc) { acc * 256 + bytes }, 0) == 44203\n bytearray.foldl(#[1, 2, 3], flip(bytearray.push), #&quot;&quot;) == #[1, 2, 3]\n ```","url":"aiken/bytearray.html#foldr"},{"doc":"aiken/bytearray","title":"from_string","content":"from_string(str: String) -&gt; ByteArray\n Convert a `String` into a `ByteArray`.\n\n ```aiken\n bytearray.from_string(&quot;ABC&quot;) == #414243\n ```","url":"aiken/bytearray.html#from_string"},{"doc":"aiken/bytearray","title":"is_empty","content":"is_empty(self: ByteArray) -&gt; Bool\n Returns `True` when the given `ByteArray` is empty.\n\n ```aiken\n bytearray.is_empty(#&quot;&quot;) == True\n bytearray.is_empty(#&quot;00ff&quot;) == False\n ```","url":"aiken/bytearray.html#is_empty"},{"doc":"aiken/bytearray","title":"length","content":"length(self: ByteArray) -&gt; Int\n Returns the number of bytes in a `ByteArray`.\n\n ```aiken\n bytearray.length(#[1, 2, 3]) == 3\n ```","url":"aiken/bytearray.html#length"},{"doc":"aiken/bytearray","title":"push","content":"push(self: ByteArray, byte: Int) -&gt; ByteArray\n Add a byte element in front of a `ByteArray`. When the given byte is\n greater than 255, it wraps-around. So 256 is mapped to 0, 257 to 1, and so\n forth.\n\n ```aiken\n bytearray.push(#&quot;&quot;, 0) == #&quot;00&quot;\n bytearray.push(#&quot;0203&quot;, 1) == #&quot;010203&quot;\n bytearray.push(#&quot;0203&quot;, 257) == #&quot;010203&quot;\n ```","url":"aiken/bytearray.html#push"},{"doc":"aiken/bytearray","title":"reduce","content":"reduce(self: ByteArray, with: fn(result, Int) -&gt; result, zero: result) -&gt; result\n Reduce bytes in a ByteArray from left to right using the accumulator as left operand.\n Said differently, this is [`foldl`](#foldl) with callback arguments swapped.\n\n ```aiken\n bytearray.reduce(#[1,2,3], bytearray.push, #[]) == #[3, 2, 1]\n ```","url":"aiken/bytearray.html#reduce"},{"doc":"aiken/bytearray","title":"slice","content":"slice(self: ByteArray, start: Int, end: Int) -&gt; ByteArray\n Extract a `ByteArray` as a slice of another `ByteArray`.\n\n Indexes are 0-based and inclusive.\n\n ```aiken\n bytearray.slice(#[0, 1, 2, 3, 4, 5, 6], start: 1, end: 3) == #[1, 2, 3]\n ```","url":"aiken/bytearray.html#slice"},{"doc":"aiken/bytearray","title":"take","content":"take(self: ByteArray, n: Int) -&gt; ByteArray\n Returns the n-length prefix of a `ByteArray`.\n\n ```aiken\n bytearray.take(#[1, 2, 3], n: 2) == #[1, 2]\n ```","url":"aiken/bytearray.html#take"},{"doc":"aiken/bytearray","title":"to_string","content":"to_string(self: ByteArray) -&gt; String\n Convert a `ByteArray` into a `String`.\n\n ```aiken\n bytearray.to_string(#&quot;414243&quot;) == &quot;ABC&quot;\n ```","url":"aiken/bytearray.html#to_string"},{"doc":"aiken/bytearray","title":"aiken/bytearray","content":"","url":"aiken/bytearray.html"},{"doc":"aiken/option","title":"and_then","content":"and_then(self: Option&lt;a&gt;, then: fn(a) -&gt; Option&lt;result&gt;) -&gt; Option&lt;result&gt;\n Chain together many computations that may fail.\n\n ```aiken\n self\n   |&gt; dict.get(policy_id)\n   |&gt; option.and_then(dict.get(_, asset_name))\n   |&gt; option.or_else(0)\n ```","url":"aiken/option.html#and_then"},{"doc":"aiken/option","title":"choice","content":"choice(self: List&lt;Option&lt;a&gt;&gt;) -&gt; Option&lt;a&gt;\n Picks the first element which is not None. If there&#39;s no such element, return None.\n\n ```aiken\n option.choice([]) == None\n option.choice([Some(14), Some(42)]) == Some(14)\n option.choice([None, Some(42)]) == Some(42)\n option.choice([None, None]) == None\n ```","url":"aiken/option.html#choice"},{"doc":"aiken/option","title":"flatten","content":"flatten(opt: Option&lt;Option&lt;a&gt;&gt;) -&gt; Option&lt;a&gt;\n Converts from `Option&lt;Option&lt;a&gt;&gt;` to `Option&lt;a&gt;`.\n\n ```aiken\n option.flatten(Some(Some(42))) == Some(42)\n option.flatten(Some(None)) == None\n option.flatten(None) == None\n ```\n\n Flattening only removes one level of nesting at a time:\n\n ```aiken\n flatten(Some(Some(Some(42)))) == Some(Some(42))\n Some(Some(Some(42))) |&gt; flatten |&gt; flatten == Some(42)\n ```","url":"aiken/option.html#flatten"},{"doc":"aiken/option","title":"is_none","content":"is_none(self: Option&lt;a&gt;) -&gt; Bool\n Asserts whether an option is `None`.","url":"aiken/option.html#is_none"},{"doc":"aiken/option","title":"is_some","content":"is_some(self: Option&lt;a&gt;) -&gt; Bool\n Asserts whether an option is `Some`, irrespective of the value it contains.","url":"aiken/option.html#is_some"},{"doc":"aiken/option","title":"map","content":"map(self: Option&lt;a&gt;, with: fn(a) -&gt; result) -&gt; Option&lt;result&gt;\n Apply a function to the inner value of an [`Option`](#option)\n\n ```aiken\n option.map(None, fn(n) { n * 2 }) == None\n option.map(Some(14), fn(n) { n * 2 }) == Some(28)\n ```","url":"aiken/option.html#map"},{"doc":"aiken/option","title":"map2","content":"map2(\n  opt_a: Option&lt;a&gt;,\n  opt_b: Option&lt;b&gt;,\n  with: fn(a, b) -&gt; result,\n) -&gt; Option&lt;result&gt;\n Combine two [`Option`](#option) together.\n\n ```aiken\n type Foo {\n   Foo(Int, Int)\n }\n\n option.map2(Foo, Some(14), Some(42)) == Some(Foo(14, 42))\n option.map2(Foo, None, Some(42)) == None\n option.map2(Foo, Some(14), None) == None\n ```","url":"aiken/option.html#map2"},{"doc":"aiken/option","title":"map3","content":"map3(\n  opt_a: Option&lt;a&gt;,\n  opt_b: Option&lt;b&gt;,\n  opt_c: Option&lt;c&gt;,\n  with: fn(a, b, c) -&gt; result,\n) -&gt; Option&lt;result&gt;\n Combine three [`Option`](#option) together.\n\n ```aiken\n type Foo {\n   Foo(Int, Int, Int)\n }\n\n option.map3(Foo, Some(14), Some(42), Some(1337)) == Some(Foo(14, 42, 1337))\n option.map3(Foo, None, Some(42), Some(1337)) == None\n option.map3(Foo, Some(14), None, None) == None\n ```","url":"aiken/option.html#map3"},{"doc":"aiken/option","title":"or_else","content":"or_else(self: Option&lt;a&gt;, default: a) -&gt; a\n Provide a default value, turning an optional value into a normal value.\n\n ```aiken\n option.or_else(None, &quot;aiken&quot;) == &quot;aiken&quot;\n option.or_else(Some(42), 14) == 42\n ```","url":"aiken/option.html#or_else"},{"doc":"aiken/option","title":"or_try","content":"or_try(self: Option&lt;a&gt;, compute_default: fn(Void) -&gt; Option&lt;a&gt;) -&gt; Option&lt;a&gt;\n Like [`or_else`](#or_else) but allows returning an `Option`.\n This is effectively mapping the error branch.\n\n ```aiken\n option.or_try(None, fn(_) { Some(&quot;aiken&quot;) }) == Some(&quot;aiken&quot;)\n option.or_try(Some(42), fn(_) { Some(14) }) == Some(42)\n ```","url":"aiken/option.html#or_try"},{"doc":"aiken/option","title":"aiken/option","content":"","url":"aiken/option.html"},{"doc":"acca/either","title":"contains","content":"contains(self: Either&lt;a, b&gt;, item: b) -&gt; Bool\n Provides information whether `Either` contains a particular element.","url":"acca/either.html#contains"},{"doc":"acca/either","title":"exists","content":"exists(self: Either&lt;a, b&gt;, with: fn(b) -&gt; Bool) -&gt; Bool\n Applies the predicate to the `Right` part, in case Either is `Left`, it returns negative.","url":"acca/either.html#exists"},{"doc":"acca/either","title":"fold","content":"fold(self: Either&lt;a, b&gt;, with_left: fn(a) -&gt; c, with_right: fn(b) -&gt; c) -&gt; c\n Fold allows to reduce `Either` to one value, there is a with_left function to reduce which reduces `Left` either and with_right which is used to reduce `Right` either.","url":"acca/either.html#fold"},{"doc":"acca/either","title":"is_left","content":"is_left(self: Either&lt;a, b&gt;) -&gt; Bool\n Whether this either is in fact `Left`.","url":"acca/either.html#is_left"},{"doc":"acca/either","title":"is_right","content":"is_right(self: Either&lt;a, b&gt;) -&gt; Bool\n Whether this either is in fact `Right`.","url":"acca/either.html#is_right"},{"doc":"acca/either","title":"left","content":"left(self: Either&lt;a, b&gt;) -&gt; a\n Forces either to be `Left`, fails with an error otherwise.","url":"acca/either.html#left"},{"doc":"acca/either","title":"map","content":"map(self: Either&lt;a, b&gt;, with: fn(b) -&gt; c) -&gt; Either&lt;a, b&gt;\n Ability to transform (map) `Right` `Left` with a given mapping function. `Left` returns value without transformation / mapping.","url":"acca/either.html#map"},{"doc":"acca/either","title":"right","content":"right(self: Either&lt;a, b&gt;) -&gt; a\n Forces either to be `Right`, fails with an error otherwise.","url":"acca/either.html#right"},{"doc":"acca/either","title":"swap","content":"swap(self: Either&lt;a, b&gt;) -&gt; Either&lt;b, a&gt;\n Swap and replace a `Left` side with a `Right` side.","url":"acca/either.html#swap"},{"doc":"acca/either","title":"to_list","content":"to_list(self: Either&lt;a, b&gt;) -&gt; List&lt;b&gt;\n Convert Either to a list.\n `Left` (usually represents errors) will be converted to an empty list\n `Right` will be converted to a list of one element","url":"acca/either.html#to_list"},{"doc":"acca/either","title":"to_option","content":"to_option(self: Either&lt;a, b&gt;) -&gt; Option&lt;b&gt;\n Allows to convert either to Option, where `Left` part is converted to None and `Right` part to Some.\n Notice that coversion of `Left` to None means we are loosing value wrapped in `Left`.","url":"acca/either.html#to_option"},{"doc":"acca/either","title":"Either","content":"Either&lt;a, b&gt; {\n  Left { value: a }\n  Right { value: b }\n}\n A common use of Either is as an alternative to an Option for dealing with possibly missing values. In this usage, None is replaced with a `Left` which can contain useful information. `Right` takes the place of scala.Some. Convention dictates that `Left` is used for failure and `Right` is used for success.\n For example, you could use Either&lt;String, Int&gt; to indicate whether a received input is a String or an Int.\nLeft { value: a }\n\nRight { value: b }\n","url":"acca/either.html#Either"},{"doc":"acca/either","title":"acca/either","content":" Represents a value of one of two possible types (a disjoint union). An instance of Either is an instance of either `Left` or `Right`.","url":"acca/either.html"},{"doc":"aiken/int","title":"compare","content":"compare(left: Int, right: Int) -&gt; Ordering\n Compare two integers.\n\n ```aiken\n compare(14, 42) == Less\n compare(14, 14) == Equal\n compare(42, 14) == Greater\n ```","url":"aiken/int.html#compare"},{"doc":"aiken/int","title":"aiken/int","content":"","url":"aiken/int.html"},{"doc":"aiken/transaction","title":"find_datum","content":"find_datum(\n  transaction: Transaction,\n  datum_hash: Hash&lt;Blake2b_256, Data&gt;,\n) -&gt; Option&lt;Data&gt;\n Find a [`Datum`](#Datum) by its hash, if present. The function looks first for\n datums in the witness set, and then for inline datums if it doesn&#39;t find any in\n witnesses.","url":"aiken/transaction.html#find_datum"},{"doc":"aiken/transaction","title":"find_input","content":"find_input(\n  transaction: Transaction,\n  output_reference: OutputReference,\n) -&gt; Option&lt;Input&gt;\n Find an input by its [`OutputReference`](#OutputReference). This is typically used in\n combination with the `Spend` [`ScriptPurpose`](#ScriptPurpose) to find a script&#39;s own\n input.\n\n ```aiken\n validator {\n   fn(datum, redeemer, ctx: ScriptContext) {\n     expect Spend(my_output_reference) =\n       ctx.purpose\n\n     expect Some(input) =\n       ctx.transaction\n         |&gt; transaction.find_input(my_output_reference)\n   }\n }\n ```","url":"aiken/transaction.html#find_input"},{"doc":"aiken/transaction","title":"find_script_outputs","content":"find_script_outputs(\n  transaction: Transaction,\n  script_hash: Hash&lt;Blake2b_224, VerificationKey&gt;,\n) -&gt; List&lt;Output&gt;\n Find all outputs that are paying into the given script hash, if any. This is useful for\n contracts running over multiple transactions.","url":"aiken/transaction.html#find_script_outputs"},{"doc":"aiken/transaction","title":"Datum","content":"Datum {\n  NoDatum\n  DatumHash(Hash&lt;Blake2b_256, Data&gt;)\n  InlineDatum(Data)\n}\n An output `Datum`.\nNoDatum\n\nDatumHash(Hash&lt;Blake2b_256, Data&gt;)\n A datum referenced by its hash digest.\nInlineDatum(Data)\n A datum completely inlined in the output.","url":"aiken/transaction.html#Datum"},{"doc":"aiken/transaction","title":"Input","content":"Input {\n  output_reference: OutputReference,\n  output: Output,\n}\n An `Input` made of an output reference and, the resolved value associated with that output.\nInput { output_reference: OutputReference, output: Output }\n","url":"aiken/transaction.html#Input"},{"doc":"aiken/transaction","title":"Output","content":"Output {\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option&lt;Hash&lt;Blake2b_224, Script&gt;&gt;,\n}\n A transaction `Output`, with an address, a value and optional datums and script references.\nOutput {\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option&lt;Hash&lt;Blake2b_224, Script&gt;&gt;,\n}\n","url":"aiken/transaction.html#Output"},{"doc":"aiken/transaction","title":"OutputReference","content":"OutputReference {\n  transaction_id: TransactionId,\n  output_index: Int,\n}\n An `OutputReference` is a unique reference to an output on-chain. The `output_index`\n corresponds to the position in the output list of the transaction (identified by its id)\n that produced that output\nOutputReference { transaction_id: TransactionId, output_index: Int }\n","url":"aiken/transaction.html#OutputReference"},{"doc":"aiken/transaction","title":"Redeemer","content":"Redeemer = Data\n A type-alias for Redeemers, passed to scripts for validation. The `Data` is\n opaque because it is user-defined and it is the script&#39;s responsability to\n parse it into its expected form.\n","url":"aiken/transaction.html#Redeemer"},{"doc":"aiken/transaction","title":"ScriptContext","content":"ScriptContext {\n  transaction: Transaction,\n  purpose: ScriptPurpose,\n}\n A context given to a script by the Cardano ledger when being executed.\n\n The context contains information about the entire transaction that contains\n the script. The transaction may also contain other scripts; to distinguish\n between multiple scripts, the `ScriptContext` also contains a `purpose`\n which indicates which script (or, for what purpose) of the transaction is\n being executed.\nScriptContext { transaction: Transaction, purpose: ScriptPurpose }\n","url":"aiken/transaction.html#ScriptContext"},{"doc":"aiken/transaction","title":"ScriptPurpose","content":"ScriptPurpose {\n  Mint(PolicyId)\n  Spend(OutputReference)\n  WithdrawFrom(StakeCredential)\n  Publish(Certificate)\n}\n Characterizes the kind of script being executed.\nMint(PolicyId)\n For scripts executed as minting/burning policies, to insert\n or remove assets from circulation. It&#39;s parameterized by the identifier\n of the associated policy.\nSpend(OutputReference)\n For scripts that are used as payment credentials for addresses in\n transaction outputs. They govern the rule by which the output they\n reference can be spent.\nWithdrawFrom(StakeCredential)\n For scripts that validate reward withdrawals from a reward account.\n\n The argument identifies the target reward account.\nPublish(Certificate)\n Needed when delegating to a pool using stake credentials defined as a\n Plutus script. This purpose is also triggered when de-registering such\n stake credentials.\n\n It embeds the certificate that&#39;s being validated.","url":"aiken/transaction.html#ScriptPurpose"},{"doc":"aiken/transaction","title":"Transaction","content":"Transaction {\n  inputs: List&lt;Input&gt;,\n  reference_inputs: List&lt;Input&gt;,\n  outputs: List&lt;Output&gt;,\n  fee: Value,\n  mint: Value,\n  certificates: List&lt;Certificate&gt;,\n  withdrawals: Dict&lt;StakeCredential, Int&gt;,\n  validity_range: ValidityRange,\n  extra_signatories: List&lt;Hash&lt;Blake2b_224, VerificationKey&gt;&gt;,\n  redeemers: Dict&lt;ScriptPurpose, Redeemer&gt;,\n  datums: Dict&lt;Hash&lt;Blake2b_256, Data&gt;, Data&gt;,\n  id: TransactionId,\n}\n A Cardano `Transaction`, as seen by Plutus scripts.\n\n Note that this is a representation of a transaction, and not the 1:1\n translation of the transaction as seen by the ledger. In particular,\n Plutus scripts can&#39;t see inputs locked by bootstrap addresses, outputs\n to bootstrap addresses or just transaction metadata.\nTransaction {\n  inputs: List&lt;Input&gt;,\n  reference_inputs: List&lt;Input&gt;,\n  outputs: List&lt;Output&gt;,\n  fee: Value,\n  mint: Value,\n  certificates: List&lt;Certificate&gt;,\n  withdrawals: Dict&lt;StakeCredential, Int&gt;,\n  validity_range: ValidityRange,\n  extra_signatories: List&lt;Hash&lt;Blake2b_224, VerificationKey&gt;&gt;,\n  redeemers: Dict&lt;ScriptPurpose, Redeemer&gt;,\n  datums: Dict&lt;Hash&lt;Blake2b_256, Data&gt;, Data&gt;,\n  id: TransactionId,\n}\n","url":"aiken/transaction.html#Transaction"},{"doc":"aiken/transaction","title":"TransactionId","content":"TransactionId {\n  hash: Hash&lt;Blake2b_256, Transaction&gt;,\n}\n A unique transaction identifier, as the hash of a transaction body. Note that the transaction id\n isn&#39;t a direct hash of the `Transaction` as visible on-chain. Rather, they correspond to hash\n digests of transaction body as they are serialized on the network.\nTransactionId { hash: Hash&lt;Blake2b_256, Transaction&gt; }\n","url":"aiken/transaction.html#TransactionId"},{"doc":"aiken/transaction","title":"ValidityRange","content":"ValidityRange = Interval&lt;PosixTime&gt;\n An interval of POSIX time, measured in number milliseconds since 1970-01-01T00:00:00Z.\n","url":"aiken/transaction.html#ValidityRange"},{"doc":"aiken/transaction","title":"aiken/transaction","content":"","url":"aiken/transaction.html"},{"doc":"aiken/math","title":"abs","content":"abs(self: Int) -&gt; Int\n Calculate the absolute value of an integer.\n\n ```aiken\n math.abs(-42) == 42\n math.abs(14) == 14\n ```","url":"aiken/math.html#abs"},{"doc":"aiken/math","title":"clamp","content":"clamp(self: Int, min: Int, max: Int) -&gt; Int\n Restrict the value of an integer between two min and max bounds\n\n ```aiken\n math.clamp(14, min: 0, max: 10) == 10\n ```","url":"aiken/math.html#clamp"},{"doc":"aiken/math","title":"log","content":"log(self: Int, base: Int) -&gt; Int\n The logarithm in base `b` of an element using integer divisions.\n\n ```aiken\n math.log(10, base: 2) == 3\n math.log(42, base: 2) == 5\n math.log(42, base: 3) == 3\n math.log(5, base: 0) == 0\n math.log(4, base: 4) == 1\n math.log(4, base: 42) == 0\n ```","url":"aiken/math.html#log"},{"doc":"aiken/math","title":"max","content":"max(a: Int, b: Int) -&gt; Int\n Return the maximum of two integers.","url":"aiken/math.html#max"},{"doc":"aiken/math","title":"min","content":"min(a: Int, b: Int) -&gt; Int\n Return the minimum of two integers.","url":"aiken/math.html#min"},{"doc":"aiken/math","title":"pow","content":"pow(self: Int, e: Int) -&gt; Int\n Calculates a number to the power of `e` using the exponentiation by\n squaring method.\n\n ```aiken\n math.pow(3, 5) == 243\n math.pow(7, 2) == 49\n math.pow(3, -4) == 0\n math.pow(0, 0) == 1\n math.pow(513, 3) == 135005697\n ```","url":"aiken/math.html#pow"},{"doc":"aiken/math","title":"aiken/math","content":" This module contains some basic Math utilities. Standard arithmetic\n operations on integers are available through native operators:\n\n Operator | Description\n ---      | :---\n `+`      | Arithmetic sum\n `-`      | Arithmetic difference\n `/`      | Whole division\n `*`      | Arithmetic multiplication\n `%`      | Remainder by whole division\n\n Here are a few examples:\n\n ```aiken\n 1 + 1   // 2\n 10 - 2  // 8\n 40 / 14 // 2\n 3 * 4   // 12\n 10 % 3  // 1","url":"aiken/math.html"},{"doc":"acca/dict","title":"sort","content":"sort(\n  self: Dict&lt;key, value&gt;,\n  key_compare: fn(key, key) -&gt; Ordering,\n) -&gt; Dict&lt;key, value&gt;\n Sort dict given it&#39;s comparator for keys.\n \n This method is useful in scenarios where offchain part passes\n unsorted dictionnary and dictonnaries are to be compared using == operator with\n on chain construction.\n\n It is recommended to pass already sorted List&lt;(a, b)&gt; from offchain to onchain\n instead of using this method.\n ```","url":"acca/dict.html#sort"},{"doc":"acca/dict","title":"acca/dict","content":"","url":"acca/dict.html"},{"doc":"acca/list","title":"append","content":"append(self: List&lt;a&gt;, item: a) -&gt; List&lt;a&gt;\n Appends an element to the end of the list.\n This operation is very cheap on functional lists.\n\n ```aiken\n alist.append([1, 2, 3], 0) == [0, 1, 2, 3]\n ```","url":"acca/list.html#append"},{"doc":"acca/list","title":"bi_diff","content":"bi_diff(self1: List&lt;a&gt;, self2: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Returns diff of two lists such that differences are returned from both lists.\n\n ```aiken\n alist.bi_diff([1, 2], [1, 3]) == [2, 3]\n ```","url":"acca/list.html#bi_diff"},{"doc":"acca/list","title":"combinations","content":"combinations(self: List&lt;a&gt;, n: Int) -&gt; List&lt;List&lt;a&gt;&gt;\n Computes combinations of items in a given list.\n\n ```aiken\n alist.combinations([3, 6, 9], 2) == [[3, 6], [6, 9], [9, 3]]\n alist.combinations([]) == []\n ```","url":"acca/list.html#combinations"},{"doc":"acca/list","title":"count","content":"count(self: List&lt;a&gt;, compare: fn(a, a) -&gt; Ordering) -&gt; Dict&lt;a, Int&gt;\n","url":"acca/list.html#count"},{"doc":"acca/list","title":"count_by","content":"count_by(\n  self: List&lt;a&gt;,\n  with: fn(a) -&gt; b,\n  compare: fn(b, b) -&gt; Ordering,\n) -&gt; Dict&lt;b, Int&gt;\n","url":"acca/list.html#count_by"},{"doc":"acca/list","title":"first","content":"first(self: List&lt;a&gt;) -&gt; Option&lt;a&gt;\n Returns first element from the list.\n This is just an alias to std lib&#39;s head function.\n\n ```aiken\n alist.first([1, 2, 3]) == Some(1)\n ```","url":"acca/list.html#first"},{"doc":"acca/list","title":"flatten","content":"flatten(self: List&lt;Option&lt;a&gt;&gt;) -&gt; List&lt;a&gt;\n Flattens items from the list such that it keeps only Some items and filters out None items.\n\n ```aiken\n aoption.flatten([Some(1), None, Some(2)]) == [1, 2]\n ```","url":"acca/list.html#flatten"},{"doc":"acca/list","title":"force_at","content":"force_at(self: List&lt;a&gt;, n: Int) -&gt; a\n Returns head of a list or error\n\n ```aiken\n alist.force_at([1, 2, 3], 0) == 1\n alist.force_at([&quot;1&quot;], 0) == &quot;1&quot;\n alist.force_at([1, 2], 3) == error\n alist.force_at([], 0) == error\n ```","url":"acca/list.html#force_at"},{"doc":"acca/list","title":"force_head","content":"force_head(self: List&lt;a&gt;) -&gt; a\n Returns head of a list or error\n\n ```aiken\n alist.force_head([1, 2, 3]) == 1\n alist.force_head([&quot;1&quot;]) == &quot;1&quot;\n alist.force_head([]) == error\n ```","url":"acca/list.html#force_head"},{"doc":"acca/list","title":"force_tail","content":"force_tail(self: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Returns tail of a list or empty list in case there is no tail.\n\n ```aiken\n alist.force_tail([1, 2, 3]) == [2, 3]\n alist.force_tail([&quot;1&quot;] ) == []\n alist.force_tail([]) == []\n ```","url":"acca/list.html#force_tail"},{"doc":"acca/list","title":"grouped","content":"grouped(self: List&lt;a&gt;, n: Int) -&gt; List&lt;List&lt;a&gt;&gt;\n Groups elements in lists of n.\n\n ```aiken\n alist.grouped([1, 2, 3, 4, 5, 6], 2) == [[1, 2], [3, 4], [5, 6]]\n alist.grouped([1, 2, 3, 4, 5, 6], 3) == [[1, 2, 3], [4, 5, 6]]\n ```","url":"acca/list.html#grouped"},{"doc":"acca/list","title":"index_of","content":"index_of(self: List&lt;a&gt;, item: a) -&gt; Option&lt;Int&gt;\n Returns index of a given list element.\n\n ```aiken\n alist.index_of([&quot;a&quot;, &quot;b&quot;, c&quot;], &quot;c&quot;) == Some(2)\n alist.index_of([&quot;a&quot;, &quot;b&quot;, c&quot;], &quot;d&quot;) == None\n ```","url":"acca/list.html#index_of"},{"doc":"acca/list","title":"indices","content":"indices(self: List&lt;a&gt;) -&gt; List&lt;Int&gt;\n Returns indices of elements from a supplied list.\n\n ```aiken\n alist.indices([&quot;a&quot;, &quot;b&quot;, c&quot;]) == [0, 1, 2]\n ```","url":"acca/list.html#indices"},{"doc":"acca/list","title":"max","content":"max(self: List&lt;a&gt;, compare: fn(a, a) -&gt; Ordering) -&gt; Option&lt;a&gt;\n Returns a max element of a given list.\n\n ```aiken\n alist.max([3, 6, 9], int.compare) == Some(9)\n alist.max([], int.compare) == None\n ```","url":"acca/list.html#max"},{"doc":"acca/list","title":"min","content":"min(self: List&lt;a&gt;, compare: fn(a, a) -&gt; Ordering) -&gt; Option&lt;a&gt;\n Returns a min element of a given list.\n\n ```aiken\n alist.min([3, 6, 9], int.compare) == Some(3)\n alist.min([], int.compare) == None\n ```","url":"acca/list.html#min"},{"doc":"acca/list","title":"non_empty","content":"non_empty(self: List&lt;a&gt;) -&gt; Bool\n Returns whether this list is NOT empty.\n\n ```aiken\n alist.non_empty([1, 2, 3]) == True\n ```","url":"acca/list.html#non_empty"},{"doc":"acca/list","title":"permutations","content":"permutations(self: List&lt;a&gt;) -&gt; List&lt;List&lt;a&gt;&gt;\n Computes permutations of items in a given list.\n\n ```aiken\n alist.permutations([1, 2, 3]) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ]\n alist.permutations([]) == [[]]\n ```","url":"acca/list.html#permutations"},{"doc":"acca/list","title":"prepend","content":"prepend(self: List&lt;a&gt;, item: a) -&gt; List&lt;a&gt;\n Prepends an item to the beginning of the list.\n This is just an alias to std lib&#39;s push function\n Notice this operation is not cheap on functional lists.\n\n ```aiken\n alist.prepend([1, 2, 3], 0) == [0, 1, 2, 3]\n ```","url":"acca/list.html#prepend"},{"doc":"acca/list","title":"product","content":"product(self: List&lt;Int&gt;) -&gt; Int\n Returns multiplication of all elements.\n\n ```aiken\n alist.min([3, 6, 9]) == 162\n alist.min([]) == 1\n ```","url":"acca/list.html#product"},{"doc":"acca/list","title":"reduce_left","content":"reduce_left(self: List&lt;a&gt;, with: fn(b, a) -&gt; b, zero: b) -&gt; b\n Reduce a list from left to right.\n\n Deprecated: please use list.reduce from stdlib.\n\n ```aiken\n alist.reduce_left([1, 2, 3], fn(n, total) { n + total }, 0) == 6\n alist.reduce_left([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], fn(a, b) { builtin.append_string(a, b), &quot;0&quot; } ) == &quot;0123&quot;\n alist.reduce_left([#[1], #[2], #[3]], fn(left, right) { bytearray.concat(left, right) }, #[9]) == #[9, 1, 2, 3]\n ```","url":"acca/list.html#reduce_left"},{"doc":"acca/list","title":"reduce_right","content":"reduce_right(self: List&lt;a&gt;, with: fn(b, a) -&gt; b, zero: b) -&gt; b\n Reduce a list from right to left.\n\n ```aiken\n alist.reduce_right([1, 2, 3], fn(n, total) { n + total }, 0) == 6\n alist.reduce_right([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], fn(a, b) { builtin.append_string(a, b) },  &quot;0&quot; ) == &quot;0321&quot;\n ```","url":"acca/list.html#reduce_right"},{"doc":"acca/list","title":"reject","content":"reject(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Filters out elements matching a given predicate.\n\n ```aiken\n alist.reject([1, 2, 3], fn(x) { x == 1 }) == [2, 3]\n ```","url":"acca/list.html#reject"},{"doc":"acca/list","title":"resolve","content":"resolve(self: List&lt;Option&lt;a&gt;&gt;) -&gt; List&lt;Option&lt;a&gt;&gt;\n Resolves items from the list such that it keeps only Some items and filters out None items.\n\n ```aiken\n aoption.resolve([Some(1), None, Some(2)]) == [Some(1), Some(2)]\n ```","url":"acca/list.html#resolve"},{"doc":"acca/list","title":"sliding","content":"sliding(self: List&lt;a&gt;, n: Int) -&gt; List&lt;List&lt;a&gt;&gt;\n Returns a sliding window of elements.\n\n ```aiken\n alist.sliding([1, 2, 3], 2) == [[1, 2], [2, 3]]\n alist.sliding([1, 2, 3, 4, 5, 6], 3) == [[1, 2, 3], [3, 4, 5], [5, 6]]\n ```","url":"acca/list.html#sliding"},{"doc":"acca/list","title":"sum","content":"sum(self: List&lt;Int&gt;) -&gt; Int\n Returns sum of all elements.\n\n ```aiken\n alist.sum([3, 6, 9]) == Some(18)\n alist.sum([]) == None\n ```","url":"acca/list.html#sum"},{"doc":"acca/list","title":"take_until","content":"take_until(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Takes elements from the list until certain predicate is matched.\n\n ```aiken\n alist.take_until([1, 2, 3, 4, 5], fn(x) { x &lt; 4 }) == [1, 2, 3]\n ```","url":"acca/list.html#take_until"},{"doc":"acca/list","title":"without","content":"without(self: List&lt;a&gt;, item: a) -&gt; List&lt;a&gt;\n Returns list without a passed in element.\n\n ```aiken\n alist.without([1, 2, 3], 1) == [2, 3]\n ```","url":"acca/list.html#without"},{"doc":"acca/list","title":"without_all","content":"without_all(self: List&lt;a&gt;, items: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Returns list without all passed in elements.\n\n ```aiken\n alist.without_all([1, 2, 3], [2, 3]) == [1]\n ```","url":"acca/list.html#without_all"},{"doc":"acca/list","title":"acca/list","content":"","url":"acca/list.html"},{"doc":"aiken/cbor","title":"diagnostic","content":"diagnostic(self: Data) -&gt; String\n Obtain a String representation of _anything_. This is particularly (and only) useful for tracing\n and debugging. This function is expensive and should not be used in any production code as it\n will very likely explodes the validator&#39;s budget.\n\n The output is a [CBOR diagnostic](https://www.rfc-editor.org/rfc/rfc8949#name-diagnostic-notation)\n of the underlying on-chain binary representation of the data. It&#39;s not as\n easy to read as plain Aiken code, but it is handy for troubleshooting values\n _at runtime_. Incidentally, getting familiar with reading CBOR diagnostic is\n a good idea in the Cardano world.\n\n ```aiken\n diagnostic(42) == &quot;42&quot;\n diagnostic(#&quot;a1b2&quot;) == &quot;h&#39;A1B2&#39;&quot;\n diagnostic([1, 2, 3]) == &quot;[1, 2, 3]&quot;\n diagnostic([]) == &quot;[]&quot;\n diagnostic((1, 2)) == &quot;[1, 2]&quot;\n diagnostic((1, #&quot;ff&quot;, 3)) == &quot;[1, h&#39;FF&#39;, 3]&quot;\n diagnostic([(1, #&quot;ff&quot;)]) == &quot;{ 1: h&#39;FF&#39; }&quot;\n diagnostic(Some(42)) == &quot;121([42])&quot;\n diagnostic(None) == &quot;122([])&quot;\n ```","url":"aiken/cbor.html#diagnostic"},{"doc":"aiken/cbor","title":"serialise","content":"serialise(self: Data) -&gt; ByteArray\n Serialise any value to binary, encoding using [CBOR](https://www.rfc-editor.org/rfc/rfc8949).\n\n This is particularly useful in combination with hashing functions, as a way\n to obtain a byte representation that matches the serialised representation\n used by the ledger in the context of on-chain code.\n\n Note that the output matches the output of [`diagnostic`](#diagnostic),\n though with a different encoding. [`diagnostic`](#diagnostic) is merely a\n textual representation of the CBOR encoding that is human friendly and\n useful for debugging.\n\n ```aiken\n serialise(42) == #&quot;182a&quot;\n serialise(#&quot;a1b2&quot;) == #&quot;42a1b2&quot;\n serialise([]) == #&quot;80&quot;\n serialise((1, 2)) == #&quot;9f0102ff&quot;\n serialise((1, #&quot;ff&quot;, 3)) == #&quot;9f0141ff03ff&quot;\n serialise([(1, #&quot;ff&quot;)]) == #&quot;a10141ff&quot;\n serialise(Some(42)) == #&quot;d8799f182aff&quot;\n serialise(None) == #&quot;d87a80&quot;\n ```","url":"aiken/cbor.html#serialise"},{"doc":"aiken/cbor","title":"aiken/cbor","content":"","url":"aiken/cbor.html"},{"doc":"acca/hash","title":"PubKeyHash","content":"PubKeyHash = Hash&lt;Blake2b_224, VerificationKey&gt;\n\n","url":"acca/hash.html#PubKeyHash"},{"doc":"acca/hash","title":"acca/hash","content":"","url":"acca/hash.html"},{"doc":"aiken/list","title":"all","content":"all(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Bool\n Determine if all elements of the list satisfy the given predicate.\n\n Note: an empty list always satisfies the predicate.\n\n ```aiken\n list.all([], fn(n) { n &gt; 0 }) == True\n list.all([1, 2, 3], fn(n) { n &gt; 0 }) == True\n list.all([1, 2, 3], fn(n) { n == 2 }) == False\n ```","url":"aiken/list.html#all"},{"doc":"aiken/list","title":"and","content":"and(self: List&lt;Bool&gt;) -&gt; Bool\n Like [all](#and) but when elements are already booleans.\n\n Note: an empty list always satisfies the predicate.\n\n ```aiken\n list.and([]) == True\n list.and([True, True]) == True\n list.and([True, False]) == False\n ```","url":"aiken/list.html#and"},{"doc":"aiken/list","title":"any","content":"any(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Bool\n Determine if at least one element of the list satisfies the given predicate.\n\n Note: an empty list never satisfies the predicate.\n\n ```aiken\n list.any([], fn(n) { n &gt; 2 }) == False\n list.any([1, 2, 3], fn(n) { n &gt; 0 }) == True\n list.any([1, 2, 3], fn(n) { n == 2 }) == True\n list.any([1, 2, 3], fn(n) { n &lt; 0 }) == False\n ```","url":"aiken/list.html#any"},{"doc":"aiken/list","title":"at","content":"at(self: List&lt;a&gt;, index: Int) -&gt; Option&lt;a&gt;\n Return Some(item) at the index or None if the index is out of range. The index is 0-based.\n\n ```aiken\n list.at([1, 2, 3], 1) == Some(2)\n list.at([1, 2, 3], 42) == None\n ```","url":"aiken/list.html#at"},{"doc":"aiken/list","title":"concat","content":"concat(left: List&lt;a&gt;, right: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Merge two lists together.\n\n ```aiken\n list.concat([], []) == []\n list.concat([], [1, 2, 3]) == [1, 2, 3]\n list.concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n ```","url":"aiken/list.html#concat"},{"doc":"aiken/list","title":"delete","content":"delete(self: List&lt;a&gt;, elem: a) -&gt; List&lt;a&gt;\n Remove the first occurence of the given element from the list.\n\n ```aiken\n list.delete([1, 2, 3, 1], 1) == [2, 3, 1]\n list.delete([1, 2, 3], 14) == [1, 2, 3]\n ```","url":"aiken/list.html#delete"},{"doc":"aiken/list","title":"difference","content":"difference(self: List&lt;a&gt;, with: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Remove the first occurence of each element of the second list from the first one.\n\n ```\n list.difference([&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;], [&quot;l&quot;, &quot;e&quot;, &quot;l&quot;]) == [&quot;h&quot;, &quot;o&quot;]\n list.difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]\n list.difference([1, 2, 3], []) == [1, 2, 3]\n ```","url":"aiken/list.html#difference"},{"doc":"aiken/list","title":"drop","content":"drop(self: List&lt;a&gt;, n: Int) -&gt; List&lt;a&gt;\n Drop the first `n` elements of a list.\n\n ```aiken\n list.drop([1, 2, 3], 2) == [3]\n list.drop([], 42) == []\n list.drop([1, 2, 3], 42) == []\n ```","url":"aiken/list.html#drop"},{"doc":"aiken/list","title":"drop_while","content":"drop_while(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Returns the suffix of the given list after removing all elements that satisfy the predicate.\n\n ```aiken\n list.drop_while([1, 2, 3], fn(x) { x &gt; 2 }) == [2, 3]\n list.drop_while([], fn(x) { x &gt; 2 }) == []\n list.drop_while([1, 2, 3], fn(x) { x == 3 }) == [1, 2, 3]\n ```","url":"aiken/list.html#drop_while"},{"doc":"aiken/list","title":"filter","content":"filter(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Produce a list of elements that statisfy a predicate.\n\n ```aiken\n list.filter([1, 2, 3], fn(x) { x &gt;= 2 }) == [2, 3]\n list.filter([], fn(x) { x &gt; 2 }) == []\n list.filter([1, 2, 3], fn(x) { x == 3 }) == [3]\n ```","url":"aiken/list.html#filter"},{"doc":"aiken/list","title":"filter_map","content":"filter_map(self: List&lt;a&gt;, predicate: fn(a) -&gt; Option&lt;b&gt;) -&gt; List&lt;b&gt;\n Produce a list of transformed elements that statisfy a predicate.\n\n ```aiken\n let transform = fn(x) { if x % 2 == 0 { None } else { Some(3*x) } }\n list.filter_map([1, 2, 3], transform) == [3, 9]\n ```","url":"aiken/list.html#filter_map"},{"doc":"aiken/list","title":"find","content":"find(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; Option&lt;a&gt;\n Find the first element satisfying the given predicate, if any.\n\n ```aiken\n list.find([1, 2, 3], fn(x) { x == 2 }) == Some(2)\n list.find([4, 5, 6], fn(x) { x == 2 }) == None\n ```","url":"aiken/list.html#find"},{"doc":"aiken/list","title":"flat_map","content":"flat_map(self: List&lt;a&gt;, with: fn(a) -&gt; List&lt;b&gt;) -&gt; List&lt;b&gt;\n Map elements of a list into a new list and flatten the result.\n\n ```aiken\n list.flat_map([1, 2, 3], fn(a) { [a, 2*a] }) == [1, 2, 2, 4, 3, 6]\n ```","url":"aiken/list.html#flat_map"},{"doc":"aiken/list","title":"foldl","content":"foldl(self: List&lt;a&gt;, with: fn(a, b) -&gt; b, zero: b) -&gt; b\n Reduce a list from left to right.\n\n ```aiken\n list.foldl([1, 2, 3], fn(n, total) { n + total }, 0) == 6\n list.foldl([1, 2, 3], fn(x, xs) { [x, ..xs] }) == [3, 2, 1]\n ```","url":"aiken/list.html#foldl"},{"doc":"aiken/list","title":"foldr","content":"foldr(self: List&lt;a&gt;, with: fn(a, b) -&gt; b, zero: b) -&gt; b\n Reduce a list from right to left.\n\n ```aiken\n list.foldr([1, 2, 3], fn(n, total) { n + total }, 0) == 6\n list.foldr([1, 2, 3], fn(x, xs) { [x, ..xs] }, 0) == [1, 2, 3]\n ```","url":"aiken/list.html#foldr"},{"doc":"aiken/list","title":"has","content":"has(self: List&lt;a&gt;, elem: a) -&gt; Bool\n Figures out whether a list contain the given element.\n\n ```aiken\n list.has([1, 2, 3], 2) == True\n list.has([1, 2, 3], 14) == False\n list.has([], 14) == False\n ```","url":"aiken/list.html#has"},{"doc":"aiken/list","title":"head","content":"head(self: List&lt;a&gt;) -&gt; Option&lt;a&gt;\n Get the first element of a list\n\n ```aiken\n list.head([1, 2, 3]) == Some(1)\n list.head([]) == None\n ```","url":"aiken/list.html#head"},{"doc":"aiken/list","title":"indexed_foldr","content":"indexed_foldr(\n  self: List&lt;a&gt;,\n  with: fn(Int, a, result) -&gt; result,\n  zero: result,\n) -&gt; result\n Like [`foldr`](#foldr), but also provides the position (0-based) of the elements when iterating.\n\n ```aiken\n let group = fn(i, x, xs) { [(i, x), ..xs] }\n list.indexed_foldr([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], group, []) == [\n   (0, &quot;a&quot;),\n   (1, &quot;b&quot;),\n   (2, &quot;c&quot;)\n ]\n ```","url":"aiken/list.html#indexed_foldr"},{"doc":"aiken/list","title":"indexed_map","content":"indexed_map(self: List&lt;a&gt;, with: fn(Int, a) -&gt; result) -&gt; List&lt;result&gt;\n List [`map`](#map) but provides the position (0-based) of the elements while iterating.\n\n ```aiken\n list.indexed_map([1, 2, 3], fn(i, x) { i + x }) == [1, 3, 5]\n ```","url":"aiken/list.html#indexed_map"},{"doc":"aiken/list","title":"init","content":"init(self: List&lt;a&gt;) -&gt; Option&lt;List&lt;a&gt;&gt;\n Return all elements except the last one.\n\n ```aiken\n list.init([]) == None\n list.init([1, 2, 3]) == Some([1, 2])\n ```","url":"aiken/list.html#init"},{"doc":"aiken/list","title":"is_empty","content":"is_empty(self: List&lt;a&gt;) -&gt; Bool\n Checks whether a list is empty.\n\n ```aiken\n list.is_empty([]) == True\n list.is_empty([1, 2, 3]) == False\n ```","url":"aiken/list.html#is_empty"},{"doc":"aiken/list","title":"last","content":"last(self: List&lt;a&gt;) -&gt; Option&lt;a&gt;\n Get the last in the given list, if any.\n\n ```aiken\n list.last([]) == None\n list.last([1, 2, 3]) == Some(3)\n ```","url":"aiken/list.html#last"},{"doc":"aiken/list","title":"length","content":"length(self: List&lt;a&gt;) -&gt; Int\n Get the number of elements in the given list.\n\n ```aiken\n list.length([]) == 0\n list.length([1, 2, 3]) == 3\n ```","url":"aiken/list.html#length"},{"doc":"aiken/list","title":"map","content":"map(self: List&lt;a&gt;, with: fn(a) -&gt; result) -&gt; List&lt;result&gt;\n Apply a function to each element of a list.\n\n ```aiken\n list.map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]\n ```","url":"aiken/list.html#map"},{"doc":"aiken/list","title":"map2","content":"map2(self: List&lt;a&gt;, bs: List&lt;b&gt;, with: fn(a, b) -&gt; result) -&gt; List&lt;result&gt;\n Apply a function of two arguments, combining elements from two lists.\n\n Note: if one list is longer, the extra elements are dropped.\n\n ```aiken\n list.map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]\n ```","url":"aiken/list.html#map2"},{"doc":"aiken/list","title":"map3","content":"map3(\n  self: List&lt;a&gt;,\n  bs: List&lt;b&gt;,\n  cs: List&lt;c&gt;,\n  with: fn(a, b, c) -&gt; result,\n) -&gt; List&lt;result&gt;\n Apply a function of three arguments, combining elements from three lists.\n\n Note: if one list is longer, the extra elements are dropped.\n\n ```aiken\n list.map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]\n ```","url":"aiken/list.html#map3"},{"doc":"aiken/list","title":"or","content":"or(self: List&lt;Bool&gt;) -&gt; Bool\n Like [any](#any) but when elements are already booleans.\n\n Note: an empty list never satisfies the predicate.\n\n ```aiken\n list.or([]) == False\n list.or([True, True]) == True\n list.or([True, False]) == True\n list.or([False, False]) == False\n ```","url":"aiken/list.html#or"},{"doc":"aiken/list","title":"partition","content":"partition(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; (List&lt;a&gt;, List&lt;a&gt;)\n Returns a tuple with all elements that satisfy the predicate at first\n element, and the rest as second element.\n\n ```aiken\n list.partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])\n ```","url":"aiken/list.html#partition"},{"doc":"aiken/list","title":"push","content":"push(self: List&lt;a&gt;, elem: a) -&gt; List&lt;a&gt;\n Add an element in front of the list. Sometimes useful when combined with\n other functions.\n\n ```aiken\n list.push([2, 3], 1) == [1, ..[2, 3]] == [1, 2, 3]\n ```","url":"aiken/list.html#push"},{"doc":"aiken/list","title":"range","content":"range(from: Int, to: Int) -&gt; List&lt;Int&gt;\n Construct a list of a integer from a given range.\n\n ```aiken\n list.range(0, 3) == [0, 1, 2, 3]\n list.range(-1, 1) == [-1, 0, 1]\n ```","url":"aiken/list.html#range"},{"doc":"aiken/list","title":"reduce","content":"reduce(self: List&lt;a&gt;, with: fn(b, a) -&gt; b, zero: b) -&gt; b\n Reduce a list from left to right using the accumulator as left operand.\n Said differently, this is [`foldl`](#foldl) with callback arguments swapped.\n\n ```aiken\n list.reduce([#[1], #[2], #[3]], bytearray.concat, #[0]) == #[0, 1, 2, 3]\n list.reduce([True, False, True], or, False) == True\n ```","url":"aiken/list.html#reduce"},{"doc":"aiken/list","title":"repeat","content":"repeat(elem: a, n_times: Int) -&gt; List&lt;a&gt;\n Construct a list filled with n copies of a value.\n\n ```aiken\n list.repeat(&quot;na&quot;, 3) == [&quot;na&quot;, &quot;na&quot;, &quot;na&quot;]\n ```","url":"aiken/list.html#repeat"},{"doc":"aiken/list","title":"reverse","content":"reverse(self: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Return the list with its elements in the reserve order.\n\n ```aiken\n list.reverse([1, 2, 3]) == [3, 2, 1]\n ```","url":"aiken/list.html#reverse"},{"doc":"aiken/list","title":"slice","content":"slice(self: List&lt;a&gt;, from: Int, to: Int) -&gt; List&lt;a&gt;\n Extract a sublist from the given list using 0-based indexes. Negative\n indexes wrap over, so `-1` refers to the last element of the list.\n\n ```aiken\n list.slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]\n list.slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]\n list.slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]\n ```","url":"aiken/list.html#slice"},{"doc":"aiken/list","title":"sort","content":"sort(self: List&lt;a&gt;, compare: fn(a, a) -&gt; Ordering) -&gt; List&lt;a&gt;\n Sort a list in ascending order using the given comparison function.\n\n ```aiken\n use aiken/int\n\n sort([3, 1, 4, 0, 2], int.compare) == [0, 1, 2, 3, 4]\n sort([1, 2, 3], int.compare) == [1, 2, 3]\n ```","url":"aiken/list.html#sort"},{"doc":"aiken/list","title":"span","content":"span(self: List&lt;a&gt;, n: Int) -&gt; (List&lt;a&gt;, List&lt;a&gt;)\n Cut a list in two, such that the first list contains the given number of /\n elements and the second list contains the rest.\n\n Fundamentally equivalent to (but more efficient):\n\n ```aiken\n span(xs, n) == (take(xs, n), drop(xs, n))\n ```","url":"aiken/list.html#span"},{"doc":"aiken/list","title":"tail","content":"tail(self: List&lt;a&gt;) -&gt; Option&lt;List&lt;a&gt;&gt;\n Get elements of a list after the first one, if any.\n\n ```aiken\n list.tail([]) == None\n list.tail([1, 2, 3]) == Some([2, 3])\n ```","url":"aiken/list.html#tail"},{"doc":"aiken/list","title":"take","content":"take(self: List&lt;a&gt;, n: Int) -&gt; List&lt;a&gt;\n Get the first `n` elements of a list.\n\n ```aiken\n list.take([1, 2, 3], 2) == [1, 2]\n list.take([1, 2, 3], 14) == [1, 2, 3]\n ```","url":"aiken/list.html#take"},{"doc":"aiken/list","title":"take_while","content":"take_while(self: List&lt;a&gt;, predicate: fn(a) -&gt; Bool) -&gt; List&lt;a&gt;\n Returns the longest prefix of the given list where all elements satisfy the predicate.\n\n ```aiken\n list.take_while([1, 2, 3], fn(x) { x &gt; 2 }) == []\n list.take_while([1, 2, 3], fn(x) { x &lt; 2 }) == [1]\n ```","url":"aiken/list.html#take_while"},{"doc":"aiken/list","title":"unique","content":"unique(self: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Removes duplicate elements from a list.\n\n ```aiken\n list.unique([1, 2, 3, 1]) == [1, 2, 3]\n ```","url":"aiken/list.html#unique"},{"doc":"aiken/list","title":"unzip","content":"unzip(self: List&lt;(a, b)&gt;) -&gt; (List&lt;a&gt;, List&lt;b&gt;)\n Decompose a list of tuples into a tuple of lists.\n\n ```\n list.unzip([(1, &quot;a&quot;), (2, &quot;b&quot;)]) == ([1, 2], [&quot;a&quot;, &quot;b&quot;])\n ```","url":"aiken/list.html#unzip"},{"doc":"aiken/list","title":"zip","content":"zip(self: List&lt;a&gt;, bs: List&lt;b&gt;) -&gt; List&lt;(a, b)&gt;\n Combine two lists together.\n\n Note: if one list is longer, the extra elements are dropped.\n\n ```aiken\n list.zip([1, 2], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) == [(1, &quot;a&quot;), (2, &quot;b&quot;)]\n ```","url":"aiken/list.html#zip"},{"doc":"aiken/list","title":"aiken/list","content":"","url":"aiken/list.html"},{"doc":"acca/option","title":"flat_map","content":"flat_map(self: Option&lt;a&gt;, with: fn(a) -&gt; Option&lt;b&gt;) -&gt; Option&lt;b&gt;\n A function that given option and a mapper function returning Option\n eventually returns Option instead of Option&lt;Option&gt;&lt;A&gt;\n\n ```aiken\n afold.flat_map(Some(1), fn(x: Int) { Some(x + 1) }) == Some(2)\n afold.flat_map(None, fn(x: Int) { Some(x + 1) }) == None\n ```","url":"acca/option.html#flat_map"},{"doc":"acca/option","title":"force_get","content":"force_get(self: Option&lt;a&gt;) -&gt; a\n A function that forces resolution of an item from this option.\n\n ```aiken\n afold.force_get(Some(1)) == 1\n afold.force_get(None) // fails\n ```","url":"acca/option.html#force_get"},{"doc":"acca/option","title":"force_head","content":"force_head(self: List&lt;a&gt;) -&gt; a\n Forces resolution of head, in case list is empty it will throw an error\n\n ```aiken\n aoption.force_head([]) == error\n aoption.force_head([1]) == 1\n ```","url":"acca/option.html#force_head"},{"doc":"acca/option","title":"force_tail","content":"force_tail(self: List&lt;a&gt;) -&gt; List&lt;a&gt;\n Forces resolution of tail, in case list is empty or has only one element it will throw an error\n\n ```aiken\n aoption.force_tail([1]) == error\n aoption.force_tail([1, 2, 3]) == [2, 3]\n ```","url":"acca/option.html#force_tail"},{"doc":"acca/option","title":"acca/option","content":"","url":"acca/option.html"},{"doc":"aiken/time","title":"PosixTime","content":"PosixTime = Int\n A number of seconds since 00:00:00 UTC on 1 January 1970.\n","url":"aiken/time.html#PosixTime"},{"doc":"aiken/time","title":"aiken/time","content":"","url":"aiken/time.html"},{"doc":"acca/collections/hashed_list","title":"from","content":"from(items: List&lt;a&gt;, hash_fn: fn(a) -&gt; Hash&lt;Sha2_256, a&gt;) -&gt; HashedList&lt;a&gt;\n","url":"acca/collections/hashed_list.html#from"},{"doc":"acca/collections/hashed_list","title":"HashedList","content":"HashedList&lt;a&gt; {\n  inner: List&lt;Hash&lt;Sha2_256, a&gt;&gt;,\n  hash: Hash&lt;Sha2_256, a&gt;,\n}\n\nHashedList { inner: List&lt;Hash&lt;Sha2_256, a&gt;&gt;, hash: Hash&lt;Sha2_256, a&gt; }\n","url":"acca/collections/hashed_list.html#HashedList"},{"doc":"acca/collections/hashed_list","title":"acca/collections/hashed_list","content":"","url":"acca/collections/hashed_list.html"},{"doc":"aiken/interval","title":"after","content":"after(lower_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values greater than the given bound. i.e [lower_bound, +INF)","url":"aiken/interval.html#after"},{"doc":"aiken/interval","title":"before","content":"before(upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values greater than the given bound. i.e (-INF, upper_bound]","url":"aiken/interval.html#before"},{"doc":"aiken/interval","title":"between","content":"between(lower_bound: a, upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values between two bounds, including the bounds. i.e. [lower_bound, upper_bound]","url":"aiken/interval.html#between"},{"doc":"aiken/interval","title":"contains","content":"contains(self: Interval&lt;Int&gt;, elem: Int) -&gt; Bool\n Checks whether an element is contained within the interval.\n\n ```aiken\n let iv =\n   Interval {\n     lower_bound: IntervalBound(Finite(14), True),\n     upper_bound: IntervalBound(Finite(42), False),\n   }\n\n interval.contains(iv, 25) // True\n interval.contains(iv, 0)  // False\n interval.contains(iv, 14) // True\n interval.contains(iv, 42) // False\n ```","url":"aiken/interval.html#contains"},{"doc":"aiken/interval","title":"empty","content":"empty() -&gt; Interval&lt;a&gt;\n Create an empty interval that contains no value.","url":"aiken/interval.html#empty"},{"doc":"aiken/interval","title":"everything","content":"everything() -&gt; Interval&lt;a&gt;\n Create an interval that contains every possible values. i.e. (-INF, +INF)","url":"aiken/interval.html#everything"},{"doc":"aiken/interval","title":"hull","content":"hull(iv1: Interval&lt;Int&gt;, iv2: Interval&lt;Int&gt;) -&gt; Interval&lt;Int&gt;\n Computes the smallest interval containing the two given intervals, if any\n\n ```aiken\n let iv1 = between(0, 10)\n let iv2 = between(2, 14)\n hull(iv1, iv2) == between(0, 14)\n\n let iv1 = between(5, 10)\n let iv2 = before(0)\n hull(iv1, iv2) == before(10)\n\n let iv1 = strictly_after(0)\n let iv2 = between(10, 42)\n hull(iv1, iv2) = strictly_after(0)\n ```","url":"aiken/interval.html#hull"},{"doc":"aiken/interval","title":"intersection","content":"intersection(iv1: Interval&lt;Int&gt;, iv2: Interval&lt;Int&gt;) -&gt; Interval&lt;Int&gt;\n Computes the largest interval contains in the two given intervals, if any.\n\n ```aiken\n let iv1 = interval.between(0, 10)\n let iv2 = interval.between(2, 14)\n interval.intersection(iv1, iv2) == interval.between(2, 10)\n\n let iv1 = interval.strictly_before(10)\n let iv2 = interval.strictly_after(0)\n interval.intersection(iv1, iv2) == interval.strictly_between(0, 10)\n\n let iv1 = interval.between(0, 1)\n let iv2 = interval.between(2, 3)\n interval.intersection(iv1, iv2) |&gt; interval.is_empty\n ```","url":"aiken/interval.html#intersection"},{"doc":"aiken/interval","title":"is_empty","content":"is_empty(self: Interval&lt;Int&gt;) -&gt; Bool\n Tells whether an interval is empty; i.e. that is contains no value.","url":"aiken/interval.html#is_empty"},{"doc":"aiken/interval","title":"max","content":"max(left: IntervalBound&lt;Int&gt;, right: IntervalBound&lt;Int&gt;) -&gt; IntervalBound&lt;Int&gt;\n Return the highest bound of the two.","url":"aiken/interval.html#max"},{"doc":"aiken/interval","title":"min","content":"min(left: IntervalBound&lt;Int&gt;, right: IntervalBound&lt;Int&gt;) -&gt; IntervalBound&lt;Int&gt;\n Return the smallest bound of the two.","url":"aiken/interval.html#min"},{"doc":"aiken/interval","title":"strictly_after","content":"strictly_after(lower_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values strictly greater than the given bound, excluding the bound itself. i.e (lower_bound, +INF)","url":"aiken/interval.html#strictly_after"},{"doc":"aiken/interval","title":"strictly_before","content":"strictly_before(upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values strictly greater than the given bound, excluding the bound itself. i.e (-INF, upper_bound)","url":"aiken/interval.html#strictly_before"},{"doc":"aiken/interval","title":"strictly_between","content":"strictly_between(lower_bound: a, upper_bound: a) -&gt; Interval&lt;a&gt;\n Create an interval that includes all values between two bounds, excluding the bounds. i.e. (lower_bound, upper_bound)","url":"aiken/interval.html#strictly_between"},{"doc":"aiken/interval","title":"Interval","content":"Interval&lt;a&gt; {\n  lower_bound: IntervalBound&lt;a&gt;,\n  upper_bound: IntervalBound&lt;a&gt;,\n}\n A type to represent intervals of values. Interval are inhabited by a type\n `a` which is useful for non-infinite intervals that have a finite\n lower-bound and/or upper-bound.\n\n This allows to represent all kind of mathematical intervals:\n\n ```aiken\n // [1; 10]\n let i0: Interval&lt;PosixTime&gt; = Interval\n   { lower_bound:\n       IntervalBound { bound_type: Finite(1), is_inclusive: True }\n   , upper_bound:\n       IntervalBound { bound_type: Finite(10), is_inclusive: True }\n   }\n ```\n\n ```aiken\n // (20; infinity)\n let i1: Interval&lt;PosixTime&gt; = Interval\n   { lower_bound:\n       IntervalBound { bound_type: Finite(20), is_inclusive: False }\n   , upper_bound:\n       IntervalBound { bound_type: PositiveInfinity, is_inclusive: False }\n   }\n ```\nInterval { lower_bound: IntervalBound&lt;a&gt;, upper_bound: IntervalBound&lt;a&gt; }\n","url":"aiken/interval.html#Interval"},{"doc":"aiken/interval","title":"IntervalBound","content":"IntervalBound&lt;a&gt; {\n  bound_type: IntervalBoundType&lt;a&gt;,\n  is_inclusive: Bool,\n}\n An interval bound, either inclusive or exclusive.\nIntervalBound { bound_type: IntervalBoundType&lt;a&gt;, is_inclusive: Bool }\n","url":"aiken/interval.html#IntervalBound"},{"doc":"aiken/interval","title":"IntervalBoundType","content":"IntervalBoundType&lt;a&gt; {\n  NegativeInfinity\n  Finite(a)\n  PositiveInfinity\n}\n A type of interval bound. Where finite, a value of type `a` must be\n provided. `a` will typically be an `Int`, representing a number of seconds or\n milliseconds.\nNegativeInfinity\n\nFinite(a)\n\nPositiveInfinity\n","url":"aiken/interval.html#IntervalBoundType"},{"doc":"aiken/interval","title":"aiken/interval","content":" In a eUTxO-based blockchain like Cardano, the management of time can be\n finicky.\n\n Indeed, in order to maintain a complete determinism in the execution of\n scripts, it is impossible to introduce a notion of _&quot;current time&quot;_ since\n the execution would then depend on factor that are external to the\n transaction itself: the ineluctable stream of time flowing in our universe.\n\n Hence, to work around that, we typically define time intervals, which gives\n window -- a.k.a intervals -- within which the transaction can be executed.\n From within a script, it isn&#39;t possible to know when exactly the script is\n executed, but we can reason about the interval bounds to validate pieces of\n logic.","url":"aiken/interval.html"},{"doc":"acca/datums","title":"is_inline_datum","content":"is_inline_datum(o: Output) -&gt; Bool\n","url":"acca/datums.html#is_inline_datum"},{"doc":"acca/datums","title":"acca/datums","content":"","url":"acca/datums.html"},{"doc":"aiken/hash","title":"blake2b_256","content":"blake2b_256(bytes: ByteArray) -&gt; Hash&lt;Blake2b_256, a&gt;\n Compute the blake2b-256 hash digest of some data.","url":"aiken/hash.html#blake2b_256"},{"doc":"aiken/hash","title":"sha2_256","content":"sha2_256(bytes: ByteArray) -&gt; Hash&lt;Sha2_256, a&gt;\n Compute the sha2-256 hash digest of some data.","url":"aiken/hash.html#sha2_256"},{"doc":"aiken/hash","title":"sha3_256","content":"sha3_256(bytes: ByteArray) -&gt; Hash&lt;Sha3_256, a&gt;\n Compute the sha3-256 hash digest of some data.","url":"aiken/hash.html#sha3_256"},{"doc":"aiken/hash","title":"Blake2b_224","content":"Blake2b_224\n A blake2b-224 hash algorithm.\n\n Typically used for:\n\n - [`Credential`](../aiken/transaction/credential.html#Credential)\n - [`PolicyId`](../aiken/transaction/value.html#PolicyId)\n\n Note: there&#39;s no function to calculate blake2b-224 hash digests on-chain.\n","url":"aiken/hash.html#Blake2b_224"},{"doc":"aiken/hash","title":"Blake2b_256","content":"Blake2b_256\n A blake2b-256 hash algorithm.\n\n Typically used for:\n\n - [`TransactionId`](../aiken/transaction.html#TransactionId)\n","url":"aiken/hash.html#Blake2b_256"},{"doc":"aiken/hash","title":"Hash","content":"Hash&lt;alg, a&gt; = ByteArray\n A `Hash` is nothing more than a `ByteArray`, but it carries extra\n information for readability.\n","url":"aiken/hash.html#Hash"},{"doc":"aiken/hash","title":"Sha2_256","content":"Sha2_256\n A SHA2-256 hash algorithm.\n","url":"aiken/hash.html#Sha2_256"},{"doc":"aiken/hash","title":"Sha3_256","content":"Sha3_256\n A SHA3-256 hash algorithm.\n","url":"aiken/hash.html#Sha3_256"},{"doc":"aiken/hash","title":"aiken/hash","content":" This module defines `Hash`, a self-documenting type-alias with a\n phantom-type for readability.\n\n On-chain, any hash digest value is represented as a plain &#39;ByteArray&#39;.\n Though in practice, hashes come from different sources and have\n different semantics.\n\n Hence, while this type-alias doesn&#39;t provide any strong type-guarantees,\n it helps writing functions signatures with more meaningful types than mere\n &#39;ByteArray&#39;.\n\n Compare for example:\n\n ```aiken\n pub type Credential {\n   VerificationKeyCredential(ByteArray)\n   ScriptCredential(ByteArray)\n }\n ```\n\n with\n\n ```aiken\n pub type Credential {\n   VerificationKeyCredential(Hash&lt;Blake2b_224, VerificationKey&gt;)\n   ScriptCredential(Hash&lt;Blake2b_224, Script&gt;)\n }\n ```\n\n Both are strictly equivalent, but the second reads much better.","url":"aiken/hash.html"},{"doc":"acca/value","title":"Lovelace","content":"Lovelace = Int\n\n","url":"acca/value.html#Lovelace"},{"doc":"acca/value","title":"acca/value","content":"","url":"acca/value.html"},{"doc":"aiken/transaction/credential","title":"from_script","content":"from_script(script: Hash&lt;Blake2b_224, Script&gt;) -&gt; Address\n Smart-constructor for an [Address](#Address) from a [script](#Script) hash. The address has no delegation rights whatsoever.","url":"aiken/transaction/credential.html#from_script"},{"doc":"aiken/transaction/credential","title":"from_verification_key","content":"from_verification_key(vk: Hash&lt;Blake2b_224, VerificationKey&gt;) -&gt; Address\n Smart-constructor for an [Address](#Address) from a [verification key](#VerificationKey) hash. The resulting address has no delegation rights whatsoever.","url":"aiken/transaction/credential.html#from_verification_key"},{"doc":"aiken/transaction/credential","title":"verify_signature","content":"verify_signature(key: VerificationKey, msg: ByteArray, sig: Signature) -&gt; Bool\n Verify an Ed25519 signature using the given verification key.\n Returns `True` when the signature is valid.","url":"aiken/transaction/credential.html#verify_signature"},{"doc":"aiken/transaction/credential","title":"with_delegation_key","content":"with_delegation_key(\n  self: Address,\n  vk: Hash&lt;Blake2b_224, VerificationKey&gt;,\n) -&gt; Address\n Set (or reset) the delegation part of an [Address](#Address) using a [verification key](#VerificationKey) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).","url":"aiken/transaction/credential.html#with_delegation_key"},{"doc":"aiken/transaction/credential","title":"with_delegation_script","content":"with_delegation_script(\n  self: Address,\n  script: Hash&lt;Blake2b_224, Script&gt;,\n) -&gt; Address\n Set (or reset) the delegation part of an [Address](#Address) using a [script](#Script) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).","url":"aiken/transaction/credential.html#with_delegation_script"},{"doc":"aiken/transaction/credential","title":"Address","content":"Address {\n  payment_credential: PaymentCredential,\n  stake_credential: Option&lt;StakeCredential&gt;,\n}\n A Cardano `Address` typically holding one or two credential references.\n\n Note that legacy bootstrap addresses (a.k.a. &#39;Byron addresses&#39;) are\n completely excluded from Plutus contexts. Thus, from an on-chain\n perspective only exists addresses of type 00, 01, ..., 07 as detailed\n in [CIP-0019 :: Shelley Addresses](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#shelley-addresses).\nAddress {\n  payment_credential: PaymentCredential,\n  stake_credential: Option&lt;StakeCredential&gt;,\n}\n","url":"aiken/transaction/credential.html#Address"},{"doc":"aiken/transaction/credential","title":"Credential","content":"Credential {\n  VerificationKeyCredential(Hash&lt;Blake2b_224, VerificationKey&gt;)\n  ScriptCredential(Hash&lt;Blake2b_224, Script&gt;)\n}\n A general structure for representing an on-chain `Credential`.\n\n Credentials are always one of two kinds: a direct public/private key\n pair, or a script (native or Plutus).\nVerificationKeyCredential(Hash&lt;Blake2b_224, VerificationKey&gt;)\n\nScriptCredential(Hash&lt;Blake2b_224, Script&gt;)\n","url":"aiken/transaction/credential.html#Credential"},{"doc":"aiken/transaction/credential","title":"PaymentCredential","content":"PaymentCredential = Credential\n A &#39;PaymentCredential&#39; represents the spending conditions associated with\n some output. Hence,\n\n - a `VerificationKeyCredential` captures an output locked by a public/private key pair;\n - and a `ScriptCredential` captures an output locked by a native or Plutus script.\n\n","url":"aiken/transaction/credential.html#PaymentCredential"},{"doc":"aiken/transaction/credential","title":"PoolId","content":"PoolId = Hash&lt;Blake2b_224, VerificationKey&gt;\n A unique stake pool identifier, as a hash of its owner verification key.\n","url":"aiken/transaction/credential.html#PoolId"},{"doc":"aiken/transaction/credential","title":"Referenced","content":"Referenced&lt;a&gt; {\n  Inline(a)\n  Pointer { slot_number: Int, transaction_index: Int, certificate_index: Int }\n}\n Represent a type of object that can be represented either inline (by hash)\n or via a reference (i.e. a pointer to an on-chain location).\n\n This is mainly use for capturing pointers to a stake credential\n registration certificate in the case of so-called pointer addresses.\nInline(a)\n\nPointer { slot_number: Int, transaction_index: Int, certificate_index: Int }\n","url":"aiken/transaction/credential.html#Referenced"},{"doc":"aiken/transaction/credential","title":"Script","content":"Script = ByteArray\n\n","url":"aiken/transaction/credential.html#Script"},{"doc":"aiken/transaction/credential","title":"Signature","content":"Signature = ByteArray\n\n","url":"aiken/transaction/credential.html#Signature"},{"doc":"aiken/transaction/credential","title":"StakeCredential","content":"StakeCredential = Referenced&lt;Credential&gt;\n A `StakeCredential` represents the delegation and rewards withdrawal conditions\n associated with some stake address / account.\n\n A `StakeCredential` is either provided inline, or, by reference using an\n on-chain pointer.\n\n Read more about pointers in [CIP-0019 :: Pointers](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#pointers).\n","url":"aiken/transaction/credential.html#StakeCredential"},{"doc":"aiken/transaction/credential","title":"VerificationKey","content":"VerificationKey = ByteArray\n\n","url":"aiken/transaction/credential.html#VerificationKey"},{"doc":"aiken/transaction/credential","title":"aiken/transaction/credential","content":"","url":"aiken/transaction/credential.html"},{"doc":"acca/math","title":"max","content":"max(left: a, right: a, compare: fn(a, a) -&gt; Ordering) -&gt; a\n Returns a max of two elements.\n\n ```aiken\n amath.max(3, 9, int.compare) == 9\n amath.max(-1, 5, int.compare) == 5\n ```","url":"acca/math.html#max"},{"doc":"acca/math","title":"min","content":"min(left: a, right: a, compare: fn(a, a) -&gt; Ordering) -&gt; a\n Returns a min of two elements.\n\n ```aiken\n amath.min(3, 9, int.compare) == 3\n amath.min(-1, 5, int.compare) == -1\n ```","url":"acca/math.html#min"},{"doc":"acca/math","title":"acca/math","content":"","url":"acca/math.html"},{"doc":"acca/constraint","title":"must_be_signed_by","content":"must_be_signed_by(transaction: Transaction, pkh: PubKeyHash) -&gt; Bool\n Function that assets that a certain transaction has been signed by a certain public key.","url":"acca/constraint.html#must_be_signed_by"},{"doc":"acca/constraint","title":"acca/constraint","content":"","url":"acca/constraint.html"},{"doc":"acca/validators","title":"any_output_contains_own_validator_address","content":"any_output_contains_own_validator_address(\n  inputs: List&lt;Input&gt;,\n  outputs: List&lt;Output&gt;,\n  output_reference: OutputReference,\n) -&gt; Bool\n This function helps in scenarios that you need to check\n whether at least one output consists of payment\n to validator&#39;s own script address.","url":"acca/validators.html#any_output_contains_own_validator_address"},{"doc":"acca/validators","title":"own_validator_script_address_hash","content":"own_validator_script_address_hash(\n  inputs: List&lt;Input&gt;,\n  output_reference: OutputReference,\n) -&gt; ValidatorHash\n","url":"acca/validators.html#own_validator_script_address_hash"},{"doc":"acca/validators","title":"ValidatorHash","content":"ValidatorHash = Hash&lt;Blake2b_224, Script&gt;\n\n","url":"acca/validators.html#ValidatorHash"},{"doc":"acca/validators","title":"acca/validators","content":"","url":"acca/validators.html"}]);